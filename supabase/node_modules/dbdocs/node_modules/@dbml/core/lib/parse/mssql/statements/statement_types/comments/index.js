"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var P = require('parsimmon');
var KP = require('../../../keyword_parsers');
var A = require('./actions');
var _require = require('../../../utils'),
  makeNode = _require.makeNode;
var Lang = P.createLanguage({
  StartComment: function StartComment() {
    return P.seq(KP.KeywordExec, KP.KeywordSP_ADDEXTENDEDPROPERTY);
  },
  EndComment: function EndComment() {
    return P.seq(KP.Semicolon.atMost(1), KP.KeywordGo);
  },
  StartString: function StartString() {
    return P.alt(KP.SingleQuote, P.string("N'"));
  },
  ManyDoubleSingleQuote: function ManyDoubleSingleQuote() {
    return P.string("''");
  },
  NoSingleQuote: function NoSingleQuote() {
    return P.regex(/[^']/);
  },
  StringType: function StringType(r) {
    return P.alt(r.NoSingleQuote, r.ManyDoubleSingleQuote).atLeast(1).map(function (res) {
      return res.join('');
    });
  },
  NVarchar: function NVarchar(r) {
    return r.StartString.then(r.StringType).skip(KP.SingleQuote);
  },
  NameOption: function NameOption(r) {
    return KP.KeywordAtName.skip(KP.Equal).then(r.NVarchar);
  },
  ValueOption: function ValueOption(r) {
    return KP.KeywordAtValue.skip(KP.Equal).then(r.NVarchar);
  },
  Level0Type: function Level0Type(r) {
    return KP.KeywordAtLevel0Type.skip(KP.Equal).then(r.NVarchar);
  },
  Level0Name: function Level0Name(r) {
    return KP.KeywordAtLevel0Name.skip(KP.Equal).then(r.NVarchar);
  },
  Level1Type: function Level1Type(r) {
    return KP.KeywordAtLevel1Type.skip(KP.Equal).then(r.NVarchar);
  },
  Level1Name: function Level1Name(r) {
    return KP.KeywordAtLevel1Name.skip(KP.Equal).then(r.NVarchar);
  },
  Level2Type: function Level2Type(r) {
    return KP.KeywordAtLevel2Type.skip(KP.Equal).then(r.NVarchar);
  },
  Level2Name: function Level2Name(r) {
    return KP.KeywordAtLevel2Name.skip(KP.Equal).then(r.NVarchar);
  },
  Level0Stmt: function Level0Stmt(r) {
    return P.seqObj(['type', r.Level0Type], KP.Comma, ['name', r.Level0Name]);
  },
  Level1Stmt: function Level1Stmt(r) {
    return P.seqObj(['type', r.Level1Type], KP.Comma, ['name', r.Level1Name]);
  },
  Level2Stmt: function Level2Stmt(r) {
    return P.seqObj(['type', r.Level2Type], KP.Comma, ['name', r.Level2Name]);
  },
  Level0Wrapper: function Level0Wrapper(r) {
    return P.alt(P.seq(r.Level0Stmt.skip(KP.Comma), r.Level1Wrapper), r.Level0Stmt).map(function (res) {
      return Array.isArray(res) ? [res[0]].concat(_toConsumableArray(res[1])) : [res];
    }).atMost(1).map(function (res) {
      return res.length === 1 ? res[0] : res;
    });
  },
  Level1Wrapper: function Level1Wrapper(r) {
    return P.alt(P.seq(r.Level1Stmt.skip(KP.Comma), r.Level2Stmt), r.Level1Stmt).map(function (res) {
      return Array.isArray(res) ? res : [res];
    });
  },
  CommentSyntax: function CommentSyntax(r) {
    return P.seqObj(r.StartComment, ['name', r.NameOption], KP.Comma, ['note', r.ValueOption], KP.Comma, ['level', r.Level0Wrapper], r.EndComment).map(A.handleComment).thru(makeNode());
  }
});
module.exports = Lang.CommentSyntax;