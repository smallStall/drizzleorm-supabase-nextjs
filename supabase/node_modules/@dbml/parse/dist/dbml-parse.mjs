import C from "lodash";
var l = /* @__PURE__ */ ((e) => (e.SPACE = "<space>", e.TAB = "<tab>", e.NEWLINE = "<newline>", e.COMMA = "<comma>", e.LPAREN = "<lparen>", e.RPAREN = "<rparen>", e.LBRACE = "<lbrace>", e.RBRACE = "<rbrace>", e.LBRACKET = "<lbracket>", e.RBRACKET = "<rbracket>", e.LANGLE = "<langle>", e.RANGLE = "<rangle>", e.OP = "<op>", e.EOF = "<eof>", e.NUMERIC_LITERAL = "<number>", e.STRING_LITERAL = "<string>", e.COLOR_LITERAL = "<color>", e.FUNCTION_EXPRESSION = "<function-expression>", e.QUOTED_STRING = "<variable>", e.IDENTIFIER = "<identifier>", e.SEMICOLON = "<semicolon>", e.COLON = "<colon>", e.SINGLE_LINE_COMMENT = "<single-line-comment>", e.MULTILINE_COMMENT = "<multiline-comment>", e))(l || {});
function tr(e) {
  switch (e.kind) {
    case "<newline>":
    case "<space>":
    case "<tab>":
    case "<single-line-comment>":
    case "<multiline-comment>":
      return !0;
    default:
      return !1;
  }
}
function at(e) {
  if (!e)
    return !1;
  switch (e) {
    case "+":
    case "-":
    case "*":
    case "/":
    case "%":
    case "<":
    case ">":
    case "=":
    case "!":
    case ".":
    case "&":
    case "|":
      return !0;
    default:
      return !1;
  }
}
function ot(e) {
  return e !== void 0 && e.kind === "<op>";
}
class P {
  constructor(t, r, s, n, i) {
    this.kind = t, this.startPos = r, this.endPos = s, this.value = n, this.leadingTrivia = [], this.trailingTrivia = [], this.leadingInvalid = [], this.trailingInvalid = [], this.isInvalid = i, this.start = r.offset, this.end = s.offset;
  }
  static create(t, r, s, n, i) {
    return new P(t, r, s, n, i);
  }
}
function xt(e) {
  return e.trailingTrivia.find(({ kind: t }) => t === l.NEWLINE) !== void 0;
}
function lt(e, t) {
  return t.leadingTrivia.find(({ kind: s }) => s === l.NEWLINE) !== void 0 || xt(e);
}
function _t(e) {
  return e.trailingTrivia.find(({ kind: t }) => t === l.SPACE) !== void 0;
}
function Ot(e) {
  return e.trailingTrivia.length === 0 ? e.end : Ot(C.last(e.trailingTrivia));
}
function vt(e) {
  return e.leadingTrivia.length === 0 ? e.start : vt(e.leadingTrivia[0]);
}
function rr(e) {
  return [l.SINGLE_LINE_COMMENT, l.MULTILINE_COMMENT].includes(
    e.kind
  );
}
class sr {
  constructor() {
    this.id = 0;
  }
  reset() {
    this.id = 0;
  }
  nextId() {
    return this.id++;
  }
}
class O {
  // The enclosing element/program
  // args must be passed in order of appearance in the node
  constructor(t, r, s) {
    this.id = t, this.kind = r;
    const n = s.find((a) => a !== void 0 && !Number.isNaN(a.start));
    n ? (this.startPos = n.startPos, this.fullStart = n instanceof P ? vt(n) : n.fullStart) : (this.startPos = {
      offset: NaN,
      column: NaN,
      line: NaN
    }, this.fullStart = NaN);
    const i = [...s].reverse().find((a) => a !== void 0 && !Number.isNaN(a.end));
    i ? (this.endPos = i.endPos, this.fullEnd = i instanceof P ? Ot(i) : i.fullEnd) : (this.endPos = {
      offset: NaN,
      column: NaN,
      line: NaN
    }, this.fullEnd = NaN), this.start = this.startPos.offset, this.end = this.endPos.offset;
  }
}
var de = /* @__PURE__ */ ((e) => (e.PROGRAM = "<program>", e.ELEMENT_DECLARATION = "<element-declaration>", e.ATTRIBUTE = "<attribute>", e.IDENTIFIER_STREAM = "<identifer-stream>", e.LITERAL = "<literal>", e.VARIABLE = "<variable>", e.PREFIX_EXPRESSION = "<prefix-expression>", e.INFIX_EXPRESSION = "<infix-expression>", e.POSTFIX_EXPRESSION = "<postfix-expression>", e.FUNCTION_EXPRESSION = "<function-expression>", e.FUNCTION_APPLICATION = "<function-application>", e.BLOCK_EXPRESSION = "<block-expression>", e.LIST_EXPRESSION = "<list-expression>", e.TUPLE_EXPRESSION = "<tuple-expression>", e.CALL_EXPRESSION = "<call-expression>", e.PRIMARY_EXPRESSION = "<primary-expression>", e.GROUP_EXPRESSION = "<group-expression>", e))(de || {});
class ae extends O {
  constructor({ body: t = [], eof: r }, s) {
    super(s, "<program>", [...t, r]), this.body = t, this.eof = r;
  }
}
class A extends O {
  constructor({
    type: t,
    name: r,
    as: s,
    alias: n,
    attributeList: i,
    bodyColon: a,
    body: o
  }, u) {
    if (super(u, "<element-declaration>", [
      t,
      r,
      s,
      n,
      i,
      a,
      o
    ]), a && !(o instanceof te || o instanceof A))
      throw new Error("If an element has a simple body, it must be a function application node");
    this.type = t, this.name = r, this.as = s, this.alias = n, this.attributeList = i, this.bodyColon = a, this.body = o;
  }
}
class q extends O {
  constructor({ identifiers: t = [] }, r) {
    super(r, "<identifer-stream>", t || []), this.identifiers = t;
  }
}
class xe extends O {
  constructor({
    name: t,
    colon: r,
    value: s
  }, n) {
    super(n, "<attribute>", [t, r, s]), this.name = t, this.value = s, this.colon = r;
  }
}
class z extends O {
  constructor({ op: t, expression: r }, s) {
    super(s, "<prefix-expression>", [t, r]), this.op = t, this.expression = r;
  }
}
class K extends O {
  constructor({
    op: t,
    leftExpression: r,
    rightExpression: s
  }, n) {
    super(n, "<infix-expression>", [r, t, s]), this.op = t, this.leftExpression = r, this.rightExpression = s;
  }
}
class Ce extends O {
  constructor({ op: t, expression: r }, s) {
    super(s, "<postfix-expression>", [r, t]), this.op = t, this.expression = r;
  }
}
class B extends O {
  constructor({ value: t }, r) {
    super(r, "<function-expression>", [t]), this.value = t;
  }
}
class te extends O {
  constructor({ callee: t, args: r = [] }, s) {
    super(s, "<function-application>", [t, ...r]), this.callee = t, this.args = r;
  }
}
class j extends O {
  constructor({
    blockOpenBrace: t,
    body: r = [],
    blockCloseBrace: s
  }, n) {
    super(n, "<block-expression>", [t, ...r, s]), this.blockOpenBrace = t, this.body = r, this.blockCloseBrace = s;
  }
}
class U extends O {
  constructor({
    listOpenBracket: t,
    elementList: r = [],
    commaList: s = [],
    listCloseBracket: n
  }, i) {
    super(i, "<list-expression>", [
      t,
      ...yt(r, s),
      n
    ]), this.listOpenBracket = t, this.elementList = r, this.commaList = s, this.listCloseBracket = n;
  }
}
class Q extends O {
  constructor({
    tupleOpenParen: t,
    elementList: r = [],
    commaList: s = [],
    tupleCloseParen: n
  }, i) {
    super(i, "<tuple-expression>", [
      t,
      ...yt(r, s),
      n
    ]), this.tupleOpenParen = t, this.elementList = r, this.commaList = s, this.tupleCloseParen = n;
  }
}
class qe extends Q {
  constructor({
    groupOpenParen: t,
    expression: r,
    groupCloseParen: s
  }, n) {
    super(
      {
        tupleOpenParen: t,
        elementList: r && [r],
        commaList: [],
        tupleCloseParen: s
      },
      n
    ), this.kind = "<group-expression>";
  }
}
class oe extends O {
  constructor({
    callee: t,
    argumentList: r
  }, s) {
    super(s, "<call-expression>", [t, r]), this.callee = t, this.argumentList = r;
  }
}
class ue extends O {
  constructor({ literal: t }, r) {
    super(r, "<literal>", [t]), this.literal = t;
  }
}
class M extends O {
  constructor({ variable: t }, r) {
    super(r, "<variable>", [t]), this.variable = t;
  }
}
class S extends O {
  constructor({ expression: t }, r) {
    super(r, "<primary-expression>", [t]), this.expression = t;
  }
}
function yt(e, t) {
  if (!e || e.length === 0)
    return t || [];
  if (!t || t.length === 0)
    return e || [];
  const [r] = e, [s] = t;
  return (r.start < s.start ? C.flatten(C.zip(e, t)) : C.flatten(C.zip(t, e))).filter(
    (n) => n !== null
  );
}
function ys(e, t = !1) {
  return JSON.stringify(
    e,
    function(r, s) {
      var n;
      return !(this instanceof ae) && r === "symbol" ? s == null ? void 0 : s.id : (
        /* this instanceof SyntaxNode && */
        r === "symbol" ? {
          symbolTable: s == null ? void 0 : s.symbolTable,
          id: s == null ? void 0 : s.id,
          references: s == null ? void 0 : s.references.map((i) => i.id),
          declaration: (n = s == null ? void 0 : s.declaration) == null ? void 0 : n.id
        } : (
          /* this instanceof SyntaxNode && */
          r === "referee" || /* this instanceof SyntaxNode && */
          r === "parent" || /* this instanceof NodeSymbol && */
          r === "declaration" ? s == null ? void 0 : s.id : (
            /* this instanceof NodeSymbol && */
            r === "symbolTable" ? Object.fromEntries(s.table) : s
          )
        )
      );
    },
    t ? 2 : 0
  );
}
class I {
  constructor(t) {
    this.value = t;
  }
  unwrap() {
    return this.value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unwrap_or(t) {
    return this.value;
  }
  and_then(t) {
    return t(this.value);
  }
  map(t) {
    return new I(t(this.value));
  }
  // eslint-disable-next-line class-methods-use-this
  isOk() {
    return !0;
  }
}
class T {
  // eslint-disable-next-line class-methods-use-this
  unwrap() {
    throw new Error("Trying to unwrap a None value");
  }
  // eslint-disable-next-line class-methods-use-this
  unwrap_or(t) {
    return t;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, class-methods-use-this
  and_then(t) {
    return new T();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, class-methods-use-this
  map(t) {
    return new T();
  }
  // eslint-disable-next-line class-methods-use-this
  isOk() {
    return !1;
  }
}
var N = /* @__PURE__ */ ((e) => (e.Schema = "Schema", e.Table = "Table", e.Column = "Column", e.TableGroup = "TableGroup", e.TableGroupField = "TableGroup field", e.Enum = "Enum", e.EnumField = "Enum field", e))(N || {});
function je(e) {
  return `Schema:${e}`;
}
function ze(e) {
  return `Table:${e}`;
}
function Ke(e) {
  return `Column:${e}`;
}
function Qe(e) {
  return `Enum:${e}`;
}
function Ye(e) {
  return `Enum field:${e}`;
}
function Me(e) {
  return `TableGroup:${e}`;
}
function kt(e) {
  return `TableGroup field:${e}`;
}
function Be(e, t) {
  switch (t) {
    case "Column":
      return Ke(e);
    case "Enum":
      return Qe(e);
    case "Enum field":
      return Ye(e);
    case "Schema":
      return je(e);
    case "Table":
      return ze(e);
    case "TableGroup":
      return Me(e);
    case "TableGroup field":
      return kt(e);
    default:
      throw new Error("Unreachable");
  }
}
function ee(e) {
  const [t, r] = e.split(":");
  return Object.values(N).includes(t) ? new I({
    name: r,
    kind: t
  }) : new T();
}
function nr(e) {
  const t = ee(e).unwrap_or(void 0);
  if (!t)
    return !1;
  const { kind: r, name: s } = t;
  return r === "Schema" && s === "public";
}
var x = /* @__PURE__ */ ((e) => (e[e.TopLevelContext = 0] = "TopLevelContext", e[e.ProjectContext = 1] = "ProjectContext", e[e.TableContext = 2] = "TableContext", e[e.TableGroupContext = 3] = "TableGroupContext", e[e.EnumContext = 4] = "EnumContext", e[e.RefContext = 5] = "RefContext", e[e.IndexesContext = 6] = "IndexesContext", e[e.NoteContext = 7] = "NoteContext", e[e.CustomContext = 8] = "CustomContext", e))(x || {});
function ir(e, t) {
  switch (e) {
    case 0:
      return t === 1 || t === 2 || t === 3 || t === 4 || t === 5;
    case 1:
      return t === 2 || t === 3 || t === 4 || t === 7 || t === 5 || t === 8;
    case 2:
      return t === 6 || t === 7 || t === 5;
    default:
      return !1;
  }
}
class ar {
  constructor() {
    this.stack = [
      0
      /* TopLevelContext */
    ];
  }
  push(t) {
    this.stack.push(t);
  }
  pop() {
    return this.stack.length === 1 ? this.stack[0] : this.stack.pop();
  }
  top() {
    return this.stack[this.stack.length - 1];
  }
  parent() {
    return this.stack.length === 1 ? this.stack[0] : this.stack[this.stack.length - 2];
  }
  isWithinContext(t) {
    for (let r = this.stack.length - 1; r >= 0; r -= 1)
      if (this.stack[r] === t)
        return !0;
    return !1;
  }
}
class we {
  constructor() {
    this.table = /* @__PURE__ */ new Map();
  }
  has(t) {
    return this.table.has(t);
  }
  set(t, r) {
    this.table.set(t, r);
  }
  get(t, r) {
    return this.table.get(t) || r !== void 0 && this.set(t, r) || r;
  }
  entries() {
    return this.table.entries();
  }
}
class or {
  constructor() {
    this.id = 0;
  }
  reset() {
    this.id = 0;
  }
  nextId() {
    return this.id++;
  }
}
class St {
  constructor({ symbolTable: t }, r) {
    this.references = [], this.id = r, this.symbolTable = t;
  }
}
class lr {
  constructor({ symbolTable: t, declaration: r }, s) {
    this.references = [], this.id = s, this.symbolTable = t, this.declaration = r;
  }
}
class cr {
  constructor({ declaration: t }, r) {
    this.references = [], this.id = r, this.declaration = t;
  }
}
class Rt {
  constructor({ symbolTable: t, declaration: r }, s) {
    this.references = [], this.id = s, this.symbolTable = t, this.declaration = r;
  }
}
class Dt {
  constructor({ declaration: t }, r) {
    this.references = [], this.id = r, this.declaration = t;
  }
}
class ur {
  constructor({ symbolTable: t, declaration: r }, s) {
    this.references = [], this.id = s, this.symbolTable = t, this.declaration = r;
  }
}
class hr {
  constructor({ declaration: t }, r) {
    this.references = [], this.id = r, this.declaration = t;
  }
}
function dr(e, t) {
  switch (t) {
    case x.TableContext:
      return ze(e);
    case x.EnumContext:
      return Qe(e);
    case x.TableGroupContext:
      return Me(e);
    default:
      return;
  }
}
function fr(e, t) {
  switch (t) {
    case x.TableContext:
      return Ke(e);
    case x.EnumContext:
      return Ye(e);
    case x.TableGroupContext:
      return Me(e);
    default:
      return;
  }
}
function ct(e, t, r) {
  switch (t) {
    case x.TableContext:
      return r.create(Rt, { symbolTable: new we(), declaration: e });
    case x.EnumContext:
      return r.create(lr, { symbolTable: new we(), declaration: e });
    case x.TableGroupContext:
      return r.create(ur, { symbolTable: new we(), declaration: e });
    default:
      return;
  }
}
function Er(e, t, r) {
  switch (t) {
    case x.TableContext:
      return r.create(Dt, { declaration: e });
    case x.EnumContext:
      return r.create(cr, { declaration: e });
    case x.TableGroupContext:
      return r.create(hr, { declaration: e });
    default:
      return;
  }
}
function pr(e) {
  return [
    je,
    ze,
    Qe,
    Me,
    Ke,
    Ye,
    kt
  ].map((t) => t(e));
}
function He(e) {
  const [t] = e;
  return t >= "a" && t <= "z" || t >= "A" && t <= "Z" || t === "_";
}
function ke(e) {
  const [t] = e;
  return t >= "0" && t <= "9";
}
function Nr(e) {
  const [t] = e;
  return ke(t) || He(t) && t.toLowerCase() >= "a" && t.toLowerCase() <= "f";
}
function Ie(e) {
  return He(e) || ke(e);
}
function ut(e, t) {
  const r = [], s = Math.min(e.length, t.length);
  for (let n = 0; n < s; n += 1)
    r.push(e[n], t[n]);
  return r.push(...e.slice(s), ...t.slice(s)), r;
}
function Ae(e, t) {
  return e >= t.start && e < t.end;
}
var c = /* @__PURE__ */ ((e) => (e[e.UNKNOWN_SYMBOL = 1e3] = "UNKNOWN_SYMBOL", e[e.UNEXPECTED_SYMBOL = 1001] = "UNEXPECTED_SYMBOL", e[e.UNEXPECTED_EOF = 1002] = "UNEXPECTED_EOF", e[e.UNEXPECTED_NEWLINE = 1003] = "UNEXPECTED_NEWLINE", e[e.UNKNOWN_TOKEN = 1004] = "UNKNOWN_TOKEN", e[e.UNEXPECTED_TOKEN = 1005] = "UNEXPECTED_TOKEN", e[e.MISPLACED_LIST_NODE = 1006] = "MISPLACED_LIST_NODE", e[e.MISSING_SPACES = 1007] = "MISSING_SPACES", e[e.UNKNOWN_PREFIX_OP = 1008] = "UNKNOWN_PREFIX_OP", e[e.INVALID_OPERAND = 1009] = "INVALID_OPERAND", e[e.EMPTY_ATTRIBUTE_NAME = 1010] = "EMPTY_ATTRIBUTE_NAME", e[e.INVALID_NAME = 3e3] = "INVALID_NAME", e[e.UNEXPECTED_NAME = 3001] = "UNEXPECTED_NAME", e[e.NAME_NOT_FOUND = 3002] = "NAME_NOT_FOUND", e[e.DUPLICATE_NAME = 3003] = "DUPLICATE_NAME", e[e.INVALID_ALIAS = 3004] = "INVALID_ALIAS", e[e.UNEXPECTED_ALIAS = 3005] = "UNEXPECTED_ALIAS", e[e.UNEXPECTED_SETTINGS = 3006] = "UNEXPECTED_SETTINGS", e[e.INVALID_SETTINGS = 3007] = "INVALID_SETTINGS", e[e.UNEXPECTED_SIMPLE_BODY = 3008] = "UNEXPECTED_SIMPLE_BODY", e[e.UNEXPECTED_COMPLEX_BODY = 3009] = "UNEXPECTED_COMPLEX_BODY", e[e.INVALID_TABLE_CONTEXT = 3010] = "INVALID_TABLE_CONTEXT", e[e.INVALID_TABLE_SETTING = 3011] = "INVALID_TABLE_SETTING", e[e.DUPLICATE_TABLE_SETTING = 3012] = "DUPLICATE_TABLE_SETTING", e[e.INVALID_TABLEGROUP_CONTEXT = 3013] = "INVALID_TABLEGROUP_CONTEXT", e[e.INVALID_TABLEGROUP_ELEMENT_NAME = 3014] = "INVALID_TABLEGROUP_ELEMENT_NAME", e[e.DUPLICATE_TABLEGROUP_ELEMENT_NAME = 3015] = "DUPLICATE_TABLEGROUP_ELEMENT_NAME", e[e.INVALID_TABLEGROUP_FIELD = 3016] = "INVALID_TABLEGROUP_FIELD", e[e.INVALID_COLUMN = 3017] = "INVALID_COLUMN", e[e.INVALID_COLUMN_NAME = 3018] = "INVALID_COLUMN_NAME", e[e.UNKNOWN_COLUMN_SETTING = 3019] = "UNKNOWN_COLUMN_SETTING", e[e.INVALID_COLUMN_TYPE = 3020] = "INVALID_COLUMN_TYPE", e[e.DUPLICATE_COLUMN_NAME = 3021] = "DUPLICATE_COLUMN_NAME", e[e.DUPLICATE_COLUMN_SETTING = 3022] = "DUPLICATE_COLUMN_SETTING", e[e.INVALID_COLUMN_SETTING_VALUE = 3023] = "INVALID_COLUMN_SETTING_VALUE", e[e.INVALID_ENUM_CONTEXT = 3024] = "INVALID_ENUM_CONTEXT", e[e.INVALID_ENUM_ELEMENT_NAME = 3025] = "INVALID_ENUM_ELEMENT_NAME", e[e.INVALID_ENUM_ELEMENT = 3026] = "INVALID_ENUM_ELEMENT", e[e.DUPLICATE_ENUM_ELEMENT_NAME = 3027] = "DUPLICATE_ENUM_ELEMENT_NAME", e[e.UNKNOWN_ENUM_ELEMENT_SETTING = 3028] = "UNKNOWN_ENUM_ELEMENT_SETTING", e[e.DUPLICATE_ENUM_ELEMENT_SETTING = 3029] = "DUPLICATE_ENUM_ELEMENT_SETTING", e[e.INVALID_ENUM_ELEMENT_SETTING = 3030] = "INVALID_ENUM_ELEMENT_SETTING", e[e.INVALID_REF_CONTEXT = 3031] = "INVALID_REF_CONTEXT", e[e.UNKNOWN_REF_SETTING = 3032] = "UNKNOWN_REF_SETTING", e[e.DUPLICATE_REF_SETTING = 3033] = "DUPLICATE_REF_SETTING", e[e.INVALID_REF_SETTING_VALUE = 3034] = "INVALID_REF_SETTING_VALUE", e[e.INVALID_REF_RELATIONSHIP = 3035] = "INVALID_REF_RELATIONSHIP", e[e.INVALID_REF_FIELD = 3036] = "INVALID_REF_FIELD", e[e.INVALID_NOTE_CONTEXT = 3037] = "INVALID_NOTE_CONTEXT", e[e.INVALID_NOTE = 3038] = "INVALID_NOTE", e[e.NOTE_REDEFINED = 3039] = "NOTE_REDEFINED", e[e.NOTE_CONTENT_REDEFINED = 3040] = "NOTE_CONTENT_REDEFINED", e[e.INVALID_INDEXES_CONTEXT = 3041] = "INVALID_INDEXES_CONTEXT", e[e.INVALID_INDEXES_FIELD = 3042] = "INVALID_INDEXES_FIELD", e[e.INVALID_INDEX = 3043] = "INVALID_INDEX", e[e.UNKNOWN_INDEX_SETTING = 3044] = "UNKNOWN_INDEX_SETTING", e[e.DUPLICATE_INDEX_SETTING = 3045] = "DUPLICATE_INDEX_SETTING", e[e.UNEXPECTED_INDEX_SETTING_VALUE = 3046] = "UNEXPECTED_INDEX_SETTING_VALUE", e[e.INVALID_INDEX_SETTING_VALUE = 3047] = "INVALID_INDEX_SETTING_VALUE", e[e.INVALID_PROJECT_CONTEXT = 3048] = "INVALID_PROJECT_CONTEXT", e[e.PROJECT_REDEFINED = 3049] = "PROJECT_REDEFINED", e[e.INVALID_PROJECT_FIELD = 3050] = "INVALID_PROJECT_FIELD", e[e.INVALID_CUSTOM_CONTEXT = 3051] = "INVALID_CUSTOM_CONTEXT", e[e.INVALID_CUSTOM_ELEMENT_VALUE = 3052] = "INVALID_CUSTOM_ELEMENT_VALUE", e[e.INVALID_ELEMENT_IN_SIMPLE_BODY = 3053] = "INVALID_ELEMENT_IN_SIMPLE_BODY", e[e.BINDING_ERROR = 4e3] = "BINDING_ERROR", e[e.UNSUPPORTED = 5e3] = "UNSUPPORTED", e[e.CIRCULAR_REF = 5001] = "CIRCULAR_REF", e[e.SAME_ENDPOINT = 5002] = "SAME_ENDPOINT", e[e.UNEQUAL_FIELDS_BINARY_REF = 5003] = "UNEQUAL_FIELDS_BINARY_REF", e[e.CONFLICTING_SETTING = 5004] = "CONFLICTING_SETTING", e))(c || {});
class w extends Error {
  constructor(t, r, s) {
    super(r), this.code = t, this.diagnostic = r, this.nodeOrToken = s, this.start = s.start, this.end = s.end, this.name = this.constructor.name, Object.setPrototypeOf(this, w.prototype);
  }
  isTokenError() {
    return this.nodeOrToken instanceof P;
  }
  isNodeError() {
    return !(this.nodeOrToken instanceof P);
  }
}
class H {
  constructor(t, r) {
    this.value = t, this.errors = r === void 0 ? [] : r;
  }
  getValue() {
    return this.value;
  }
  getErrors() {
    return this.errors;
  }
  chain(t) {
    const r = t(this.value), s = [...this.errors, ...r.errors];
    return new H(r.value, s);
  }
  map(t) {
    return new H(t(this.value), this.errors);
  }
}
function br(e, t, r) {
  if (!e || !Ir(e) || t.length === 0)
    return new T();
  const s = [...t], n = ve(e).unwrap(), i = s.pop();
  if (!(i instanceof j))
    return new T();
  const a = C.last(s) instanceof U ? s.pop() : void 0;
  return s.length === 3 && ve(s[1]).unwrap().value === "as" ? new I(
    r.create(A, {
      type: n,
      name: s[0],
      as: ve(s[1]).unwrap(),
      alias: s[2],
      attributeList: a,
      body: i
    })
  ) : s.length === 1 ? new I(
    r.create(A, {
      type: n,
      name: s[0],
      attributeList: a,
      body: i
    })
  ) : s.length === 0 ? new I(
    r.create(A, {
      type: n,
      attributeList: a,
      body: i
    })
  ) : new T();
}
function ht(e) {
  return e.kind === l.IDENTIFIER && e.value === "as";
}
function E(e) {
  e && (e instanceof P ? mr(e) : gr(e));
}
function mr(e) {
  e.kind !== l.EOF && (e.isInvalid = !0);
}
function gr(e) {
  if (e instanceof A)
    E(e.type), E(e.name), E(e.as), E(e.alias), E(e.bodyColon), E(e.attributeList), E(e.body);
  else if (e instanceof q)
    e.identifiers.forEach(E);
  else if (e instanceof xe)
    E(e.name), E(e.colon), E(e.value);
  else if (e instanceof z)
    E(e.op), E(e.expression);
  else if (e instanceof K)
    E(e.leftExpression), E(e.op), E(e.rightExpression);
  else if (e instanceof Ce)
    E(e.op), E(e.expression);
  else if (e instanceof j)
    E(e.blockOpenBrace), e.body.forEach(E), E(e.blockCloseBrace);
  else if (e instanceof U)
    E(e.listOpenBracket), e.commaList.forEach(E), e.elementList.forEach(E), E(e.listCloseBracket);
  else if (e instanceof Q)
    E(e.tupleOpenParen), e.commaList.forEach(E), e.elementList.forEach(E), E(e.tupleCloseParen);
  else if (e instanceof oe)
    E(e.callee), E(e.argumentList);
  else if (e instanceof te)
    E(e.callee), e.args.forEach(E);
  else if (e instanceof S)
    E(e.expression);
  else if (e instanceof B)
    E(e.value);
  else if (e instanceof M)
    E(e.variable);
  else if (e instanceof ue)
    E(e.literal);
  else
    throw e instanceof qe ? new Error("This case is handled by the TupleExpressionNode case") : new Error("Unreachable case in markInvalidNode");
}
function Ct(e) {
  return !!(e != null && e.isInvalid);
}
function D(...e) {
  return e.filter((t) => t !== void 0);
}
function Tr(e) {
  if (e instanceof ae)
    return D(...e.body, e.eof);
  if (e instanceof A)
    return D(
      e.type,
      e.name,
      e.as,
      e.alias,
      e.attributeList,
      e.bodyColon,
      e.body
    );
  if (e instanceof xe)
    return D(e.name, e.colon, e.value);
  if (e instanceof q)
    return e.identifiers;
  if (e instanceof ue)
    return e.literal ? [e.literal] : [];
  if (e instanceof M)
    return D(e.variable);
  if (e instanceof z)
    return D(e.op, e.expression);
  if (e instanceof K)
    return D(e.leftExpression, e.op, e.rightExpression);
  if (e instanceof Ce)
    return D(e.expression, e.op);
  if (e instanceof B)
    return D(e.value);
  if (e instanceof te)
    return D(e.callee, ...e.args);
  if (e instanceof j)
    return D(e.blockOpenBrace, ...e.body, e.blockCloseBrace);
  if (e instanceof U)
    return D(
      e.listOpenBracket,
      ...ut(e.elementList, e.commaList),
      e.listCloseBracket
    );
  if (e instanceof Q)
    return D(
      e.tupleOpenParen,
      ...ut(e.elementList, e.commaList),
      e.tupleCloseParen
    );
  if (e instanceof oe)
    return D(e.callee, e.argumentList);
  if (e instanceof S)
    return D(e.expression);
  throw e instanceof qe ? new Error("This case is already handled by TupleExpressionNode") : new Error("Unreachable - no other possible cases");
}
function ve(e) {
  return Y(e) ? new I(e.expression.variable) : new T();
}
function J(e) {
  var t;
  return e instanceof S && (e.expression instanceof M && e.expression.variable instanceof P || e.expression instanceof ue && ((t = e.expression.literal) == null ? void 0 : t.kind) === l.STRING_LITERAL);
}
function Y(e) {
  return e instanceof S && e.expression instanceof M && e.expression.variable instanceof P;
}
function Ir(e) {
  var t;
  return e instanceof S && e.expression instanceof M && ((t = e.expression.variable) == null ? void 0 : t.kind) === l.IDENTIFIER;
}
function Pe(e) {
  var t;
  return e instanceof K && e.leftExpression instanceof O && e.rightExpression instanceof O && ((t = e.op) == null ? void 0 : t.value) === ".";
}
function le(e) {
  if (e === void 0)
    return new T();
  const t = e.identifiers.map((r) => r.value).join(" ");
  return t === "" ? new T() : new I(t);
}
function dt(e) {
  return e.create(B, {});
}
function Mt(e) {
  return e instanceof B && e.value === void 0;
}
class Lr {
  // list of errors during lexing
  constructor(t) {
    this.start = {
      offset: 0,
      line: 0,
      column: 0
    }, this.current = {
      offset: 0,
      line: 0,
      column: 0
    }, this.tokens = [], this.errors = [], this.text = t;
  }
  isAtEnd() {
    return this.current.offset >= this.text.length;
  }
  advance() {
    const t = this.peek();
    return this.current = { ...this.current }, t === `
` ? (this.current.line += 1, this.current.column = 0) : this.current.column += 1, this.current.offset += 1, t;
  }
  peek(t = 0) {
    if (!(this.current.offset + t >= this.text.length))
      return this.text[this.current.offset + t];
  }
  // Check if the sequence ahead matches `sequence`
  check(t) {
    for (let r = 0; r < t.length; r += 1)
      if (t[r] !== this.peek(r))
        return !1;
    return !0;
  }
  // If the sequence ahead matches `sequence`, move `current` past `sequence`
  match(t) {
    return this.check(t) ? (t.split("").forEach(() => this.advance()), !0) : !1;
  }
  addToken(t, r = !1) {
    this.tokens.push(this.createToken(t, r));
  }
  createToken(t, r = !1) {
    return P.create(
      t,
      this.start,
      this.current,
      this.text.substring(this.start.offset, this.current.offset),
      r
    );
  }
  lex() {
    return this.scanTokens(), this.tokens.push(P.create(l.EOF, this.start, this.current, "", !1)), this.gatherTrivia(), this.gatherInvalid(), new H(this.tokens, this.errors);
  }
  scanTokens() {
    for (; !this.isAtEnd(); ) {
      const t = this.advance();
      switch (t) {
        case " ":
          this.addToken(l.SPACE);
          break;
        case "\r":
          break;
        case `
`:
          this.addToken(l.NEWLINE);
          break;
        case "	":
          this.addToken(l.TAB);
          break;
        case ",":
          this.addToken(l.COMMA);
          break;
        case "(":
          this.addToken(l.LPAREN);
          break;
        case ")":
          this.addToken(l.RPAREN);
          break;
        case "[":
          this.addToken(l.LBRACKET);
          break;
        case "]":
          this.addToken(l.RBRACKET);
          break;
        case "{":
          this.addToken(l.LBRACE);
          break;
        case "}":
          this.addToken(l.RBRACE);
          break;
        case ";":
          this.addToken(l.SEMICOLON);
          break;
        case ":":
          this.addToken(l.COLON);
          break;
        case "'":
          this.match("''") ? this.multilineStringLiteral() : this.singleLineStringLiteral();
          break;
        case '"':
          this.quotedVariable();
          break;
        case "`":
          this.functionExpression();
          break;
        case "#":
          this.colorLiteral();
          break;
        case "/":
          this.match("/") ? this.singleLineComment() : this.match("*") ? this.multilineComment() : this.operator();
          break;
        default:
          if (at(t)) {
            this.operator();
            break;
          }
          if (He(t)) {
            this.identifier();
            break;
          }
          if (ke(t)) {
            this.numericLiteral();
            break;
          }
          this.addToken(l.OP, !0), this.errors.push(
            new w(
              c.UNKNOWN_SYMBOL,
              `Unexpected token '${t}'`,
              this.createToken(l.OP, !0)
            )
          );
          break;
      }
      this.start = { ...this.current };
    }
  }
  gatherTrivia() {
    let t = !0, r = [], s;
    const n = [];
    for (const i of this.tokens)
      tr(i) ? (r.push(i), i.kind === l.NEWLINE && s && (s.trailingTrivia = r, t = !0, s = void 0, r = [])) : (t ? i.leadingTrivia = r : s.trailingTrivia = r, n.push(i), r = [], s = i, t = !1);
    this.tokens = n;
  }
  gatherInvalid() {
    let t;
    const r = [], s = [];
    for (t = 0; t < this.tokens.length && Ct(this.tokens[t]); t += 1)
      s.push(this.tokens[t]);
    let n = this.tokens[t];
    for (n.leadingInvalid = [...s, ...n.leadingInvalid]; t < this.tokens.length; t += 1) {
      const i = this.tokens[t];
      i.isInvalid ? n.trailingInvalid.push(i) : (n = i, r.push(i));
    }
    this.tokens = r;
  }
  // Consuming characters until the `stopSequence` is encountered
  consumeUntil(t, r, {
    allowNewline: s,
    // Whether newline is allowed
    allowEof: n,
    // Whether EOF is allowed
    raw: i,
    // Whether to interpret '\' as a backlash
    consumeStopSequence: a = !0
  }) {
    let o = "";
    for (; !this.isAtEnd() && (s || !this.check(`
`)) && !this.check(r); )
      this.peek() === "\\" && !i ? (this.advance(), o += this.escapedString()) : o += this.advance();
    if (this.isAtEnd() && !n) {
      const u = this.createToken(t, !0);
      this.tokens.push(u), this.errors.push(
        new w(c.UNEXPECTED_EOF, "EOF reached while parsing", u)
      );
      return;
    }
    if (this.check(`
`) && !s) {
      const u = this.createToken(t, !0);
      this.tokens.push(u), this.errors.push(
        new w(
          c.UNEXPECTED_NEWLINE,
          "Invalid newline encountered while parsing",
          u
        )
      );
      return;
    }
    a && this.match(r), this.tokens.push(P.create(t, this.start, this.current, o, !1));
  }
  singleLineStringLiteral() {
    this.consumeUntil(l.STRING_LITERAL, "'", {
      allowNewline: !1,
      allowEof: !1,
      raw: !1
    });
  }
  multilineStringLiteral() {
    this.consumeUntil(l.STRING_LITERAL, "'''", {
      allowNewline: !0,
      allowEof: !1,
      raw: !1
    });
  }
  functionExpression() {
    this.consumeUntil(l.FUNCTION_EXPRESSION, "`", {
      allowNewline: !1,
      allowEof: !1,
      raw: !0
    });
  }
  quotedVariable() {
    this.consumeUntil(l.QUOTED_STRING, '"', {
      allowNewline: !1,
      allowEof: !1,
      raw: !1
    });
  }
  singleLineComment() {
    this.consumeUntil(l.SINGLE_LINE_COMMENT, `
`, {
      allowNewline: !0,
      allowEof: !0,
      raw: !0,
      consumeStopSequence: !1
    });
  }
  multilineComment() {
    this.consumeUntil(l.MULTILINE_COMMENT, "*/", {
      allowNewline: !0,
      allowEof: !1,
      raw: !0
    });
  }
  identifier() {
    for (; !this.isAtEnd() && Ie(this.peek()); )
      this.advance();
    this.addToken(l.IDENTIFIER);
  }
  operator() {
    for (; at(this.peek()); )
      this.advance();
    this.addToken(l.OP);
  }
  numericLiteral() {
    let t = 0;
    if (this.isAtEnd())
      return this.addToken(l.NUMERIC_LITERAL);
    for (; !this.isAtEnd(); ) {
      const s = this.check(".");
      if (t += s ? 1 : 0, t > 1)
        break;
      if (!s && this.current.offset === this.text.length - 1)
        return this.advance(), this.addToken(l.NUMERIC_LITERAL);
      if (!s && !Ie(this.peek()))
        return this.addToken(l.NUMERIC_LITERAL);
      if (!s && !ke(this.peek()))
        break;
      this.advance();
    }
    for (; !this.isAtEnd() && (this.check(".") || Ie(this.peek())); )
      this.advance();
    const r = this.createToken(l.NUMERIC_LITERAL, !0);
    this.tokens.push(r), this.errors.push(new w(c.UNKNOWN_TOKEN, "Invalid number", r));
  }
  colorLiteral() {
    for (; !this.isAtEnd() && Ie(this.peek()); )
      this.advance();
    this.addToken(l.COLOR_LITERAL);
  }
  escapedString() {
    if (this.isAtEnd())
      return "\\";
    switch (this.advance()) {
      case "t":
        return "	";
      case "n":
        return `
`;
      case "\\":
        return "\\";
      case "r":
        return "\r";
      case "'":
        return "'";
      case '"':
        return '"';
      case "0":
        return "\0";
      case "b":
        return "\b";
      case "v":
        return "\v";
      case "f":
        return "\f";
      case "u": {
        let t = "";
        for (let r = 0; r <= 3; r += 1) {
          if (this.isAtEnd() || !Ie(this.peek()))
            return `\\u${t}`;
          t += this.advance();
        }
        return String.fromCharCode(parseInt(t, 16));
      }
      default:
        return `\\${this.tokens[this.current.offset - 1]}`;
    }
  }
}
var ye = /* @__PURE__ */ ((e) => (e[e.ListExpression = 0] = "ListExpression", e[e.GroupExpression = 1] = "GroupExpression", e[e.BlockExpression = 2] = "BlockExpression", e))(ye || {});
class wr {
  constructor() {
    this.stack = [], this.numberOfNestedLParens = 0, this.numberOfNestedLBrackets = 0, this.numberOfNestedLBraces = 0;
  }
  push(t) {
    this.stack.push(t), t === 0 && (this.numberOfNestedLBrackets += 1), t === 1 && (this.numberOfNestedLParens += 1), t === 2 && (this.numberOfNestedLBraces += 1);
  }
  pop() {
    const t = this.stack.pop();
    return t === 0 && (this.numberOfNestedLBrackets -= 1), t === 1 && (this.numberOfNestedLParens -= 1), t === 2 && (this.numberOfNestedLBraces -= 1), t;
  }
  top() {
    return C.last(this.stack);
  }
  isWithinGroupExpressionContext() {
    return this.numberOfNestedLParens > 0;
  }
  isWithinListExpressionContext() {
    return this.numberOfNestedLBrackets > 0;
  }
  isWithinBlockExpressionContext() {
    return this.numberOfNestedLBraces > 0;
  }
  // Call the passed in callback
  // with the guarantee that the passed in context will be pushed and popped properly
  // even in cases of exceptions
  withContextDo(t, r) {
    return () => {
      this.push(t);
      try {
        return r();
      } finally {
        this.pop();
      }
    };
  }
  // Return the type of the handler context currently in the context stack to handle `token`
  findHandlerContext(t, r) {
    if (!(this.numberOfNestedLBraces <= 0 && this.numberOfNestedLBrackets <= 0 && this.numberOfNestedLParens <= 0))
      for (let s = r; s < t.length - 1; s += 1)
        switch (t[s].kind) {
          case l.COMMA:
            if (this.isWithinGroupExpressionContext() || this.isWithinListExpressionContext())
              return [...this.stack].reverse().find(
                (i) => [
                  1,
                  0
                  /* ListExpression */
                ].includes(i)
              );
            break;
          case l.RPAREN:
            if (this.isWithinGroupExpressionContext())
              return 1;
            break;
          case l.RBRACE:
            if (this.isWithinBlockExpressionContext())
              return 2;
            break;
          case l.RBRACKET:
            if (this.isWithinListExpressionContext())
              return 0;
            break;
        }
  }
}
class Ar {
  constructor(t) {
    this.generator = t;
  }
  create(t, r) {
    return new t(r, this.generator.nextId());
  }
}
class d {
  constructor(t, r, s) {
    this.token = t, this.partialNode = r, this.handlerContext = s;
  }
}
class xr {
  constructor(t, r) {
    this.current = 0, this.errors = [], this.contextStack = new wr(), this.synchronizeProgram = () => {
      const s = this.peek();
      s.kind !== l.EOF ? E(this.advance()) : (E(this.peek()), this.logError(s, c.UNEXPECTED_EOF, "Unexpected EOF"));
    }, this.synchronizeElementDeclarationName = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (ht(s) || this.check(l.COLON, l.LBRACE, l.LBRACKET))
          break;
        E(s), this.advance();
      }
    }, this.synchronizeElementDeclarationAlias = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (this.check(l.COLON, l.LBRACE, l.LBRACKET))
          break;
        E(s), this.advance();
      }
    }, this.blockExpression = this.contextStack.withContextDo(ye.BlockExpression, () => {
      const s = { body: [] }, n = () => this.nodeFactory.create(j, s);
      try {
        this.consume("Expect an opening brace '{'", l.LBRACE), s.blockOpenBrace = this.previous();
      } catch (i) {
        if (!(i instanceof d))
          throw i;
        if (s.blockOpenBrace = i.partialNode, !this.canHandle(i))
          throw new d(i.token, n(), i.handlerContext);
        this.synchronizeBlock();
      }
      for (; !this.isAtEnd() && !this.check(l.RBRACE); )
        try {
          s.body.push(this.canBeField() ? this.fieldDeclaration() : this.expression());
        } catch (i) {
          if (!(i instanceof d))
            throw i;
          if (s.body.push(i.partialNode), !this.canHandle(i))
            throw new d(i.token, n(), i.handlerContext);
          this.synchronizeBlock();
        }
      try {
        this.consume("Expect a closing brace '}'", l.RBRACE), s.blockCloseBrace = this.previous();
      } catch (i) {
        if (!(i instanceof d))
          throw i;
        if (s.blockCloseBrace = i.partialNode, !this.canHandle(i))
          throw new d(i.token, n(), i.handlerContext);
        this.synchronizeBlock();
      }
      return n();
    }), this.synchronizeBlock = () => {
      if (!this.check(l.RBRACE))
        for (E(this.advance()); !this.isAtEnd(); ) {
          const s = this.peek();
          if (this.check(l.RBRACE) || lt(this.previous(), s))
            break;
          E(s), this.advance();
        }
    }, this.tupleExpression = this.contextStack.withContextDo(ye.GroupExpression, () => {
      const s = { elementList: [], commaList: [] }, n = () => this.nodeFactory.create(qe, {
        groupOpenParen: s.tupleOpenParen,
        groupCloseParen: s.tupleCloseParen,
        expression: s.elementList[0]
      }), i = () => this.nodeFactory.create(Q, s);
      try {
        this.consume("Expect an opening parenthesis '('", l.LPAREN), s.tupleOpenParen = this.previous();
      } catch (a) {
        if (!(a instanceof d))
          throw a;
        if (s.tupleOpenParen = a.partialNode, !this.canHandle(a))
          throw new d(a.token, i(), a.handlerContext);
        this.synchronizeTuple();
      }
      if (!this.isAtEnd() && !this.check(l.RPAREN))
        try {
          s.elementList.push(this.normalExpression());
        } catch (a) {
          if (!(a instanceof d))
            throw a;
          if (s.elementList.push(a.partialNode), !this.canHandle(a))
            throw new d(a.token, n(), a.handlerContext);
          this.synchronizeTuple();
        }
      for (; !this.isAtEnd() && !this.check(l.RPAREN); )
        try {
          this.consume("Expect a comma ','", l.COMMA), s.commaList.push(this.previous()), s.elementList.push(this.normalExpression());
        } catch (a) {
          if (!(a instanceof d))
            throw a;
          if (a.partialNode instanceof O && s.elementList.push(a.partialNode), !this.canHandle(a))
            throw new d(a.token, i(), a.handlerContext);
          this.synchronizeTuple();
        }
      try {
        this.consume("Expect a closing parenthesis ')'", l.RPAREN), s.tupleCloseParen = this.previous();
      } catch (a) {
        if (!(a instanceof d))
          throw a;
        if (s.tupleCloseParen = a.partialNode, !this.canHandle(a))
          throw new d(a.token, i(), a.handlerContext);
        this.synchronizeTuple();
      }
      return s.elementList.length === 1 ? n() : i();
    }), this.synchronizeTuple = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (this.check(l.RPAREN, l.COMMA))
          break;
        E(s), this.advance();
      }
    }, this.listExpression = this.contextStack.withContextDo(ye.ListExpression, () => {
      const s = { elementList: [], commaList: [] }, n = () => this.nodeFactory.create(U, s);
      try {
        this.consume("Expect an opening bracket '['", l.LBRACKET), s.listOpenBracket = this.previous();
      } catch (i) {
        if (!(i instanceof d))
          throw i;
        if (s.listOpenBracket = i.partialNode, !this.canHandle(i))
          throw new d(i.token, n(), i.handlerContext);
        this.synchronizeList();
      }
      if (!this.isAtEnd() && !this.check(l.RBRACKET))
        try {
          s.elementList.push(this.attribute());
        } catch (i) {
          if (!(i instanceof d))
            throw i;
          if (s.elementList.push(i.partialNode), !this.canHandle(i))
            throw new d(i.token, n(), i.handlerContext);
          this.synchronizeList();
        }
      for (; !this.isAtEnd() && !this.check(l.RBRACKET); )
        try {
          this.consume("Expect a comma ','", l.COMMA), s.commaList.push(this.previous()), s.elementList.push(this.attribute());
        } catch (i) {
          if (!(i instanceof d))
            throw i;
          if (s.elementList.push(i.partialNode), !this.canHandle(i))
            throw new d(i.token, n(), i.handlerContext);
          this.synchronizeList();
        }
      try {
        this.consume("Expect a closing bracket ']'", l.RBRACKET), s.listCloseBracket = this.previous();
      } catch (i) {
        if (!(i instanceof d))
          throw i;
        if (s.listCloseBracket = i.partialNode, !this.canHandle(i))
          throw new d(i.token, n(), i.handlerContext);
        this.synchronizeList();
      }
      return n();
    }), this.synchronizeList = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (this.check(l.COMMA, l.RBRACKET))
          break;
        E(s), this.advance();
      }
    }, this.synchronizeAttributeName = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (this.check(l.COMMA, l.RBRACKET, l.COLON))
          break;
        E(s), this.advance();
      }
    }, this.synchronizeAttributeValue = () => {
      for (; !this.isAtEnd(); ) {
        const s = this.peek();
        if (this.check(l.COMMA, l.RBRACKET))
          break;
        E(s), this.advance();
      }
    }, this.tokens = t, this.nodeFactory = new Ar(r);
  }
  isAtEnd() {
    return this.current >= this.tokens.length || this.tokens[this.current].kind === l.EOF;
  }
  advance() {
    return this.isAtEnd() ? C.last(this.tokens) : this.tokens[this.current++];
  }
  peek(t = 0) {
    return t + this.current >= this.tokens.length ? C.last(this.tokens) : this.tokens[this.current + t];
  }
  match(...t) {
    const r = this.check(...t);
    return r && this.advance(), r;
  }
  check(...t) {
    const r = this.peek();
    return t.includes(r.kind);
  }
  previous() {
    return this.tokens[this.current - 1];
  }
  canHandle(t) {
    return t.handlerContext === void 0 || t.handlerContext === this.contextStack.top();
  }
  consume(t, ...r) {
    if (!this.match(...r))
      throw this.logError(this.peek(), c.UNEXPECTED_TOKEN, t), new d(
        this.peek(),
        void 0,
        this.contextStack.findHandlerContext(this.tokens, this.current)
      );
  }
  // Discard tokens until one of `kind` is found
  // If any tokens are discarded, the error message is logged
  // Return whether the token of one of the listed kinds are eventually reached
  discardUntil(t, ...r) {
    if (this.isAtEnd() || !this.check(...r)) {
      for (E(this.peek()), this.logError(this.advance(), c.UNEXPECTED_TOKEN, t); !this.isAtEnd() && !this.check(...r); )
        E(this.advance());
      return !this.isAtEnd();
    }
    return !0;
  }
  gatherInvalid() {
    const t = [], r = [];
    let s, n = 0;
    for (; n < this.tokens.length && this.tokens[n].isInvalid; n += 1)
      r.push(this.tokens[n]);
    for (s = this.tokens[n], s.leadingInvalid = r, t.push(s), n += 1; n < this.tokens.length; n += 1) {
      const i = this.tokens[n];
      i.isInvalid ? s.trailingInvalid.push(i) : (s = i, t.push(s));
    }
    this.tokens = t;
  }
  parse() {
    const t = this.program(), r = this.advance(), s = this.nodeFactory.create(ae, { body: t, eof: r });
    return this.gatherInvalid(), new H({ ast: s, tokens: this.tokens }, this.errors);
  }
  /* Parsing and synchronizing ProgramNode */
  program() {
    const t = [];
    for (; !this.isAtEnd(); )
      try {
        const r = this.elementDeclaration();
        t.push(r);
      } catch (r) {
        if (!(r instanceof d))
          throw r;
        t.push(r.partialNode), this.synchronizeProgram();
      }
    return t;
  }
  /* Parsing and synchronizing top-level ElementDeclarationNode */
  elementDeclaration() {
    const t = {}, r = () => this.nodeFactory.create(A, t);
    try {
      this.consume("Expect an identifier", l.IDENTIFIER), t.type = this.previous();
    } catch (s) {
      throw s instanceof d ? (t.type = s.partialNode, new d(s.token, r(), s.handlerContext)) : s;
    }
    if (!this.check(l.COLON, l.LBRACE, l.LBRACKET))
      try {
        t.name = this.normalExpression();
      } catch (s) {
        if (!(s instanceof d))
          throw s;
        if (t.name = s.partialNode, !this.canHandle(s))
          throw new d(s.token, r(), s.handlerContext);
        this.synchronizeElementDeclarationName();
      }
    if (ht(this.peek()))
      if (t.as = this.advance(), this.check(l.COLON, l.LBRACE, l.LBRACKET))
        this.logError(this.peek(), c.UNEXPECTED_TOKEN, "Expect an alias");
      else
        try {
          t.alias = this.normalExpression();
        } catch (s) {
          if (!(s instanceof d))
            throw s;
          if (t.alias = s.partialNode, !this.canHandle(s))
            throw new d(s.token, r(), s.handlerContext);
          this.synchronizeElementDeclarationAlias();
        }
    try {
      t.attributeList = this.check(l.LBRACKET) ? this.listExpression() : void 0;
    } catch (s) {
      throw s instanceof d ? (t.attributeList = s.partialNode, new d(s.token, r(), s.handlerContext)) : s;
    }
    if (!this.discardUntil(
      "Expect an opening brace '{' or a colon ':'",
      l.LBRACE,
      l.COLON
    ))
      return r();
    try {
      this.match(l.COLON) ? (t.bodyColon = this.previous(), t.body = this.expression()) : t.body = this.blockExpression();
    } catch (s) {
      throw s instanceof d ? (t.body = s.partialNode, new d(s.token, r(), s.handlerContext)) : s;
    }
    return this.nodeFactory.create(A, t);
  }
  /* Parsing nested element declarations with simple body */
  // e.g
  // ```
  //  Table Users {
  //    Note: 'This is a note'  // fieldDeclaration() handles this
  //  }
  fieldDeclaration() {
    const t = {}, r = () => this.nodeFactory.create(A, t);
    try {
      this.consume("Expect an identifier", l.IDENTIFIER), t.type = this.previous();
    } catch (s) {
      throw s instanceof d ? (t.type = s.partialNode, new d(s.token, r(), s.handlerContext)) : s;
    }
    try {
      this.consume("Expect a colon ':'", l.COLON), t.bodyColon = this.previous();
    } catch (s) {
      throw s instanceof d ? (t.bodyColon = s.partialNode, new d(s.token, r(), s.handlerContext)) : s;
    }
    try {
      t.body = this.expression();
    } catch (s) {
      throw s instanceof d ? (t.body = s.partialNode, new d(s.token, r(), s.handlerContext)) : s;
    }
    return this.nodeFactory.create(A, t);
  }
  /* Parsing any ExpressionNode, including non-NormalExpression */
  expression() {
    const t = { args: [] }, r = () => br(t.callee, t.args, this.nodeFactory).unwrap_or(
      this.nodeFactory.create(te, t)
    );
    try {
      t.callee = this.normalExpression();
    } catch (n) {
      throw n instanceof d ? (t.callee = n.partialNode, new d(n.token, r(), n.handlerContext)) : n;
    }
    if (this.shouldStopExpression())
      return r();
    let s = t.callee;
    for (; !this.shouldStopExpression(); ) {
      _t(this.previous()) || this.logError(s, c.MISSING_SPACES, "Expect a following space");
      try {
        s = this.normalExpression(), t.args.push(s);
      } catch (n) {
        throw n instanceof d ? (s = n.partialNode, t.args.push(s), new d(n.token, r(), n.handlerContext)) : n;
      }
    }
    return r();
  }
  shouldStopExpression() {
    if (this.isAtEnd() || xt(this.previous()))
      return !0;
    const t = this.peek().kind;
    return t === l.RBRACE || t === l.RBRACKET || t === l.RPAREN || t === l.COMMA || t === l.COLON;
  }
  normalExpression() {
    return this.expression_bp(0);
  }
  // Pratt's parsing algorithm
  expression_bp(t) {
    let r = this.leftExpression_bp();
    for (; !this.isAtEnd(); ) {
      const s = this.peek();
      if (s.kind === l.LPAREN) {
        const { left: n } = ft(s);
        if (n < t || // When '(' is encountered,
        // consider it part of another expression if
        // it's at the start of a new line
        // and we're currently not having unmatched '(' or '['
        lt(this.previous(), s) && !this.contextStack.isWithinGroupExpressionContext() && !this.contextStack.isWithinListExpressionContext())
          break;
        try {
          r = this.nodeFactory.create(oe, {
            callee: r,
            argumentList: this.tupleExpression()
          });
        } catch (i) {
          throw i instanceof d ? (r = this.nodeFactory.create(oe, {
            callee: r,
            argumentList: i.partialNode
          }), new d(i.token, r, i.handlerContext)) : i;
        }
      } else if (ot(s)) {
        const n = s, i = ft(n);
        if (i.left !== null) {
          if (i.left <= t)
            break;
          this.advance(), r = this.nodeFactory.create(Ce, {
            expression: r,
            op: n
          });
        } else {
          const a = Or(n);
          if (a.left === null || a.left <= t)
            break;
          this.advance();
          try {
            r = this.nodeFactory.create(K, {
              leftExpression: r,
              op: n,
              rightExpression: n.value === "." ? this.extractOperand() : this.expression_bp(a.right)
            });
          } catch (o) {
            throw o instanceof d ? (r = this.nodeFactory.create(K, {
              leftExpression: r,
              op: n,
              rightExpression: o.partialNode
            }), new d(o.token, r, o.handlerContext)) : o;
          }
        }
      } else
        break;
    }
    return r;
  }
  leftExpression_bp() {
    let t;
    if (ot(this.peek())) {
      const r = {};
      r.op = this.peek();
      const s = yr(r.op);
      s.right === null && (this.logError(
        r.op,
        c.UNKNOWN_PREFIX_OP,
        `Unexpected '${r.op.value}' in an expression`
      ), this.throwDummyOperand(r.op)), this.advance();
      try {
        r.expression = this.expression_bp(s.right);
      } catch (n) {
        throw n instanceof d ? (r.expression = n.partialNode, new d(
          n.token,
          this.nodeFactory.create(z, r),
          n.handlerContext
        )) : n;
      }
      t = this.nodeFactory.create(z, r);
    } else
      t = this.extractOperand(), Mt(t) && this.throwDummyOperand(this.peek());
    return t;
  }
  // Extract an operand to be used in a normal form expression
  // e.g (1 + 2) in (1 + 2) * 3
  // e.g [1, 2, 3, 4]
  // e.g { ... }
  extractOperand() {
    return this.check(
      l.NUMERIC_LITERAL,
      l.STRING_LITERAL,
      l.COLOR_LITERAL,
      l.QUOTED_STRING,
      l.IDENTIFIER
    ) ? this.primaryExpression() : this.check(l.FUNCTION_EXPRESSION) ? this.functionExpression() : this.check(l.LBRACKET) ? this.listExpression() : this.check(l.LBRACE) ? this.blockExpression() : this.check(l.LPAREN) ? this.tupleExpression() : (this.peek().kind === l.EOF ? this.logError(
      this.peek(),
      c.UNEXPECTED_EOF,
      "Unexpected EOF"
    ) : this.logError(
      this.peek(),
      c.INVALID_OPERAND,
      `Invalid start of operand "${this.peek().value}"`
    ), dt(this.nodeFactory));
  }
  throwDummyOperand(t) {
    throw new d(
      t,
      dt(this.nodeFactory),
      this.contextStack.findHandlerContext(this.tokens, this.current)
    );
  }
  /* Parsing FunctionExpression */
  functionExpression() {
    const t = {};
    try {
      this.consume("Expect a function expression", l.FUNCTION_EXPRESSION), t.value = this.previous();
    } catch (r) {
      throw r instanceof d ? (t.value = r.partialNode, new d(
        r.token,
        this.nodeFactory.create(B, t),
        r.handlerContext
      )) : r;
    }
    return this.nodeFactory.create(B, t);
  }
  canBeField() {
    return this.peek().kind === l.IDENTIFIER && this.peek(1).kind === l.COLON;
  }
  /* Parsing PrimaryExpression */
  primaryExpression() {
    if (this.match(
      l.COLOR_LITERAL,
      l.STRING_LITERAL,
      l.NUMERIC_LITERAL
    ))
      return this.nodeFactory.create(S, {
        expression: this.nodeFactory.create(ue, { literal: this.previous() })
      });
    if (this.match(l.QUOTED_STRING, l.IDENTIFIER))
      return this.nodeFactory.create(S, {
        expression: this.nodeFactory.create(M, { variable: this.previous() })
      });
    throw this.logError(this.peek(), c.UNEXPECTED_TOKEN, "Expect a variable or literal"), new d(
      this.peek(),
      this.nodeFactory.create(S, {
        expression: this.nodeFactory.create(M, {})
      }),
      this.contextStack.findHandlerContext(this.tokens, this.current)
    );
  }
  attribute() {
    const t = {};
    if (this.check(l.COLON, l.RBRACKET, l.COMMA)) {
      const r = this.peek();
      this.logError(
        r,
        c.EMPTY_ATTRIBUTE_NAME,
        "Expect a non-empty attribute name"
      ), t.name = this.nodeFactory.create(q, { identifiers: [] });
    } else
      try {
        t.name = this.extractIdentifierStream();
      } catch (r) {
        if (!(r instanceof d))
          throw r;
        if (t.name = r.partialNode, !this.canHandle(r))
          throw new d(
            r.token,
            this.nodeFactory.create(xe, t),
            r.handlerContext
          );
        this.synchronizeAttributeName();
      }
    return this.match(l.COLON) && (t.colon = this.previous(), t.value = this.attributeValue()), this.nodeFactory.create(xe, t);
  }
  attributeValue() {
    let t;
    try {
      t = this.peek().kind === l.IDENTIFIER && this.peek(1).kind === l.IDENTIFIER ? this.extractIdentifierStream() : this.normalExpression();
    } catch (r) {
      if (!(r instanceof d) || !this.canHandle(r))
        throw r;
      t = r.partialNode, this.synchronizeAttributeValue();
    }
    return t;
  }
  extractIdentifierStream() {
    const t = [];
    for (; !this.isAtEnd() && !this.check(l.COLON, l.COMMA, l.RBRACKET); )
      if (this.match(
        l.QUOTED_STRING,
        l.STRING_LITERAL,
        l.NUMERIC_LITERAL
      ))
        E(this.previous()), this.logError(this.previous(), c.UNEXPECTED_TOKEN, "Expect an identifier");
      else
        try {
          this.consume("Expect an identifier", l.IDENTIFIER), t.push(this.previous());
        } catch (r) {
          throw r instanceof d ? new d(
            r.token,
            this.nodeFactory.create(q, { identifiers: t }),
            r.handlerContext
          ) : r;
        }
    return this.nodeFactory.create(q, { identifiers: t });
  }
  logError(t, r, s) {
    this.errors.push(new w(r, s, t));
  }
}
const _r = {
  "+": { left: 9, right: 10 },
  "*": { left: 11, right: 12 },
  "-": { left: 9, right: 10 },
  "/": { left: 11, right: 12 },
  "%": { left: 11, right: 12 },
  "<": { left: 7, right: 8 },
  "<=": { left: 7, right: 8 },
  ">": { left: 7, right: 8 },
  ">=": { left: 7, right: 8 },
  "<>": { left: 7, right: 8 },
  "=": { left: 2, right: 3 },
  "==": { left: 4, right: 5 },
  "!=": { left: 4, right: 5 },
  ".": { left: 16, right: 17 }
};
function Or(e) {
  return _r[e.value] || { left: null, right: null };
}
const vr = {
  "+": { left: null, right: 15 },
  "-": { left: null, right: 15 },
  "<": { left: null, right: 15 },
  ">": { left: null, right: 15 },
  "<>": { left: null, right: 15 },
  "!": { left: null, right: 15 }
};
function yr(e) {
  return vr[e.value] || { left: null, right: null };
}
const kr = {
  "(": { left: 14, right: null }
};
function ft(e) {
  return kr[e.value] || { left: null, right: null };
}
function Ee(e) {
  if (!Pe(e))
    return new I([e]);
  const t = Ee(e.leftExpression).unwrap_or(void 0);
  return t ? (t.push(e.rightExpression), new I(t)) : new T();
}
function pe(e) {
  if (e === void 0)
    return new T();
  const t = Ee(e).unwrap_or(void 0);
  if (!t)
    return new T();
  const r = [];
  for (const s of t) {
    const n = Je(s).unwrap_or(void 0);
    if (!n)
      return new T();
    r.push(n);
  }
  return new I(r);
}
function Ge(e) {
  if (e === void 0)
    return new T();
  const t = Ee(e).unwrap_or(void 0);
  if (!t || t.length === 0)
    return new T();
  const r = [];
  let s;
  if (!Y(C.last(t))) {
    const n = t.pop();
    if (jt(n))
      s = n.elementList.map(
        (i) => W(i).unwrap()
      );
    else
      return new T();
  }
  for (const n of t) {
    const i = Je(n).unwrap_or(void 0);
    if (!i)
      return new T();
    r.push(i);
  }
  return new I({
    variables: r,
    tupleElements: s
  });
}
function Je(e) {
  return Y(e) ? new I(e.expression.variable.value) : new T();
}
function Pt(e) {
  if (Et(e))
    return e instanceof B ? new I({ functional: [e], nonFunctional: [] }) : new I({ functional: [], nonFunctional: [e] });
  if (e instanceof Q && e.elementList.every(Et)) {
    const t = e.elementList.filter(
      (s) => s instanceof B
    ), r = e.elementList.filter(Y);
    return new I({ functional: t, nonFunctional: r });
  }
  return new T();
}
function W(e) {
  var r;
  const t = (r = e.expression.variable) == null ? void 0 : r.value;
  return t === void 0 ? new T() : new I(t);
}
function fe(e) {
  return J(e) ? e.expression instanceof M ? new I(e.expression.variable.value) : new I(e.expression.literal.value) : new T();
}
function Sr(e) {
  var t;
  return !(e instanceof K) || !qt((t = e.op) == null ? void 0 : t.value) ? !1 : Ge(e.leftExpression).and_then(() => Ge(e.rightExpression)).unwrap_or(void 0) !== void 0;
}
function Et(e) {
  return e instanceof S && e.expression instanceof M || e instanceof B;
}
function Rr(e, t) {
  var n, i, a, o;
  let r = t;
  const s = nr(e);
  for (; r; ) {
    if ((i = (n = r.symbol) == null ? void 0 : n.symbolTable) != null && i.has(e))
      return (a = r.symbol.symbolTable) == null ? void 0 : a.get(e);
    if (((o = r.symbol) == null ? void 0 : o.declaration) instanceof ae && s)
      return r.symbol;
    if (r instanceof ae)
      return;
    r = r.parent;
  }
}
var m = /* @__PURE__ */ ((e) => (e.TABLE = "Table", e.ENUM = "Enum", e.INDEXES = "Indexes", e.NOTE = "Note", e.PROJECT = "Project", e.REF = "Ref", e.TABLEGROUP = "TableGroup", e.CUSTOM = "custom element", e))(m || {});
function Ze(e) {
  if (e.globally && !e.notGloballyErrorCode)
    throw new Error(
      "Misconfigurartion: If an element is globally unique, notGloballyErrorCode must be set"
    );
  if (e.locally && !e.notLocallyErrorCode)
    throw new Error(
      "Misconfigurartion: If an element is locally unique, notLocallyErrorCode must be set"
    );
  return e;
}
function et(e) {
  if (!e.optional && !e.notOptionalErrorCode)
    throw new Error(
      "Misconfiguration: If name is not optional, notOptionalErrorCode must be present"
    );
  if (!e.allow && !e.notAllowErrorCode)
    throw new Error("Misconfiguration: If name is not allowed, notAllowErrorCode must be present");
  if (e.shouldRegister && !e.duplicateErrorCode)
    throw new Error(
      "Misconfiguration: If name should be registered, duplicateErrorCode must be present"
    );
  return e;
}
function Ut(e) {
  if (!e.optional && !e.notOptionalErrorCode)
    throw new Error(
      "Misconfiguration: If alias is not optional, notOptionalErrorCode must be present"
    );
  if (!e.allow && !e.notAllowErrorCode)
    throw new Error("Misconfiguration: If alias is not allowed, notAllowErrorCode must be present");
  return e;
}
function Ne(e, t) {
  if (!t.optional && !t.notOptionalErrorCode)
    throw new Error(
      "Misconfiguration: If settingList is not optional, notOptionalErrorCode must be present"
    );
  if (!t.allow && !t.notAllowErrorCode)
    throw new Error(
      "Misconfiguration: If settingList is not allowed, notAllowErrorCode must be present"
    );
  if (t.allow && !t.unknownErrorCode)
    throw new Error(
      "Misconfiguration: If settingList is allowed, unknownErrorCode must be present"
    );
  if (t.allow && !t.duplicateErrorCode)
    throw new Error(
      "Misconfiguration: If settingList is allowed, duplicateErrorCode must be present"
    );
  if (t.allow && !t.invalidErrorCode)
    throw new Error(
      "Misconfiguration: If settingList is allowed, notAllowErrorCode must be present"
    );
  return {
    ...t,
    isValid(r, s) {
      const n = e[r];
      return n ? new I(n.isValid(s)) : new T();
    },
    allowDuplicate(r) {
      const s = e[r];
      return s ? new I(s.allowDuplicate) : new T();
    }
  };
}
function tt(e) {
  if (!e.allowSimple && !e.simpleErrorCode)
    throw new Error("Misconfiguration: If simple body is not allowed, simpleErrorCode must be set");
  if (!e.allowComplex && !e.complexErrorCode)
    throw new Error(
      "Misconfiguration: If complex body is not allowed, complexErrorCode must be set"
    );
  return e;
}
function re(e) {
  if (e.shouldRegister && !e.duplicateErrorCode)
    throw new Error(
      "Misconfiguration: If subfield should be registered, duplicateErrorCode must be present"
    );
  return e;
}
function Dr(e) {
  return e === m.CUSTOM;
}
function Ve(e) {
  switch (e) {
    case m.TABLE:
      return "column";
    case m.ENUM:
      return "field";
    case m.TABLEGROUP:
      return "table";
    default:
      return "subfield";
  }
}
function ce(e, t, r) {
  return (s, n) => e(s, n) ? [] : [new w(t, r, s)];
}
class se {
  constructor(t, r, s, n, i, a, o) {
    this.declarationNode = t, this.publicSchemaSymbol = r, this.contextStack = s, this.errors = n, this.kindsGloballyFound = i, this.kindsLocallyFound = a, this.symbolFactory = o;
  }
  validate() {
    this.contextStack.push(this.context.name);
    const t = this.validateContext() && this.validateUnique() && this.validateName() && this.validateAlias() && this.validateSettingList() && this.validateBodyForm() && this.validateBodyContent();
    return this.contextStack.pop(), t;
  }
  /* Validate uniqueness according to config `this.unique` */
  validateUnique() {
    return this.validateGloballyUnique() && this.validateLocallyUnique() || !this.unique.stopOnError;
  }
  validateLocallyUnique() {
    return this.unique.locally ? this.kindsLocallyFound.has(this.elementKind) ? (this.logError(
      this.declarationNode.type,
      this.unique.notLocallyErrorCode,
      `A(n) ${this.elementKind} has already been defined in this scope`
    ), !1) : (this.kindsLocallyFound.add(this.elementKind), !0) : !0;
  }
  validateGloballyUnique() {
    return this.unique.globally ? this.kindsGloballyFound.has(this.elementKind) ? (this.logError(
      this.declarationNode.type,
      this.unique.notGloballyErrorCode,
      `A(n) ${this.elementKind} has already been defined in this file`
    ), !1) : (this.kindsGloballyFound.add(this.elementKind), !0) : !0;
  }
  /* Validate context according to config `this.context` */
  validateContext() {
    return ir(this.contextStack.parent(), this.contextStack.top()) ? !0 : (this.logError(
      this.declarationNode.type,
      this.context.errorCode,
      Dr(this.elementKind) ? "Unknown element type" : `A(n) ${this.elementKind} can not appear here`
    ), !this.context.stopOnError);
  }
  /* Validate and register name according to config `this.name` */
  validateName() {
    return this.declarationNode.symbol = ct(
      this.declarationNode,
      this.context.name,
      this.symbolFactory
    ), this.checkNameInValidForm() && this.checkNameAllowed() && this.checkNameOptional() && this.checkNameComplex() && // Short-circuting prevents registerName to be called if a previous check fails
    this.registerName() || !this.name.stopOnError;
  }
  checkNameInValidForm() {
    const { name: t } = this.declarationNode;
    return t && Mt(t) ? !1 : t && !Wt(t) ? (this.logError(t, c.INVALID_NAME, "Invalid element name"), !1) : !0;
  }
  checkNameAllowed() {
    return !this.name.allow && this.declarationNode.name ? (this.logError(
      this.declarationNode.name,
      this.name.notAllowErrorCode,
      `A(n) ${this.elementKind} shouldn't have a name`
    ), !1) : !0;
  }
  checkNameOptional() {
    return !this.name.optional && !this.declarationNode.name ? (this.logError(
      this.declarationNode.type,
      this.name.notOptionalErrorCode,
      `A(n) ${this.elementKind} must have a name`
    ), !1) : !0;
  }
  checkNameComplex() {
    const { name: t } = this.declarationNode;
    return !this.name.allowComplex && t && !Xe(t) ? (this.logError(
      t,
      this.name.complexErrorCode,
      `A(n) ${this.elementKind} must have a double-quoted string or an identifier name`
    ), !1) : !0;
  }
  registerName() {
    if (this.declarationNode.name && this.name.shouldRegister) {
      const { registeredSymbol: t, ok: r } = this.registerElement(this.declarationNode.name);
      return this.declarationNode.symbol = t, r;
    }
    return !0;
  }
  /* Validate and register alias according to config `this.alias` */
  validateAlias() {
    return this.checkAliasInValidForm() && this.checkAliasAllow() && this.checkAliasOptional() && // Short-circuting prevents registerAlias to be called if a previous check fails
    this.registerAlias() || !this.alias.stopOnError;
  }
  checkAliasInValidForm() {
    const { alias: t } = this.declarationNode;
    return t && !Jr(t) ? (this.logError(t, c.INVALID_ALIAS, "Invalid element alias"), !1) : !0;
  }
  checkAliasAllow() {
    const { alias: t } = this.declarationNode;
    return !this.alias.allow && t ? (this.logError(
      t,
      this.alias.notAllowErrorCode,
      `A(n) ${this.elementKind} shouldn't have an alias`
    ), !1) : !0;
  }
  checkAliasOptional() {
    const { alias: t } = this.declarationNode;
    return !this.alias.optional && !t ? (this.logError(
      this.declarationNode.type,
      this.alias.notOptionalErrorCode,
      `A(n) ${this.elementKind} must have an alias`
    ), !1) : !0;
  }
  registerAlias() {
    const { alias: t } = this.declarationNode;
    if (t && this.name.shouldRegister) {
      const { ok: r } = this.registerElement(t, this.declarationNode.symbol);
      return r;
    }
    return !0;
  }
  // Register a name extracted from `nameNode` into the `public` schema
  // Also check for duplicated name
  // If `defaultSymbol` is undefined, create the symbol anew corresponding to the name
  // If `defaultSymbol` is given, the symbol (and its symbol table) is reused
  registerElement(t, r) {
    const s = pe(t).unwrap_or(void 0);
    if (!s)
      throw new Error(`${this.elementKind} must be a valid complex variable`);
    const n = s.pop();
    if (!n)
      throw new Error(`${this.elementKind} name shouldn't be empty`);
    const i = dr(n, this.context.name);
    s[0] === "public" && s.shift();
    const a = ts(
      s,
      this.publicSchemaSymbol.symbolTable,
      this.symbolFactory
    );
    if (!i)
      throw new Error(`${this.elementKind} fails to create id to register in the symbol table`);
    const o = ct(
      this.declarationNode,
      this.context.name,
      this.symbolFactory
    );
    if (!o)
      throw new Error(
        `${this.elementKind} fails to create a symbol to register in the symbol table`
      );
    return a.has(i) ? (this.logError(
      t,
      this.name.duplicateErrorCode,
      `${this.elementKind} "${n}" has been defined`
    ), { registeredSymbol: r || o, ok: !1 }) : (a.set(i, r || o), { registeredSymbol: r || o, ok: !0 });
  }
  /* Validate element according to config `this.settingList` */
  validateSettingList() {
    return this.checkSettingListInValidForm() && this.checkSettingListAllow() && this.checkSettingListOptional() && (!this.declarationNode.attributeList || this.validateSettingListContent(this.declarationNode.attributeList, this.settingList)) || !this.settingList.stopOnError;
  }
  checkSettingListInValidForm() {
    const { attributeList: t } = this.declarationNode;
    return t && !Zr(t) ? (this.logError(t, c.INVALID_SETTINGS, "SettingList must be a list"), !1) : !0;
  }
  checkSettingListAllow() {
    const { attributeList: t } = this.declarationNode;
    return !this.settingList.allow && t ? (this.logError(
      t,
      this.settingList.notAllowErrorCode,
      `A(n) ${this.elementKind} shouldn't have a setting list`
    ), !1) : !0;
  }
  checkSettingListOptional() {
    const { attributeList: t } = this.declarationNode;
    return !this.settingList.optional && !t ? (this.logError(
      this.declarationNode.type,
      this.settingList.notOptionalErrorCode,
      `A(n) ${this.elementKind} must have a setting list`
    ), !1) : !0;
  }
  /* Validate body format according to config `this.body` */
  validateBodyForm() {
    const t = this.declarationNode;
    if (!t.body)
      return !1;
    let r = !1;
    return !this.body.allowComplex && Nt(t) && (this.logError(
      t.body,
      this.body.complexErrorCode,
      `A(n) ${this.elementKind} should not have a complex body`
    ), r = !0), !this.body.allowSimple && es(t) && (this.logError(
      t.body,
      this.body.simpleErrorCode,
      `A(n) ${this.elementKind} should not have a simple body`
    ), r = !0), !r || !this.body.stopOnError;
  }
  /* Validate the body content */
  validateBodyContent() {
    const t = this.declarationNode;
    if (!t.body)
      return !1;
    if (Nt(t)) {
      if (!this.body.allowComplex)
        return !1;
      const r = /* @__PURE__ */ new Set();
      let s = !1, n = -1;
      return s = !t.body.body.map((i) => i instanceof A ? !i.type || this.validateNestedElementDeclaration(i, r) : (n += 1, !i.callee || this.validateSubField(i, n))).every((i) => !!i) || s, !s;
    }
    return t.body instanceof te && t.body.callee ? this.validateSubField(
      t.body,
      0
    ) : (this.logError(
      t.body,
      c.INVALID_ELEMENT_IN_SIMPLE_BODY,
      "An element's simple body can not contain an element declaration"
    ), !1);
  }
  validateNestedElementDeclaration(t, r) {
    if (t.parent = this.declarationNode, !t.type)
      return !1;
    const s = t, n = $t(s);
    return new n(
      s,
      this.publicSchemaSymbol,
      this.contextStack,
      this.errors,
      this.kindsGloballyFound,
      r,
      this.symbolFactory
    ).validate();
  }
  /* Validate and register subfield according to config `this.subfield` */
  validateSubField(t, r) {
    const n = [t.callee, ...t.args];
    if (n.length === 0)
      throw new Error("A function application node always has at least 1 callee");
    const i = n[n.length - 1];
    if (this.validateSubFieldSettingList(i), i instanceof U && n.pop(), n.length !== this.subfield.argValidators.length)
      return this.logError(
        t,
        this.subfield.invalidArgNumberErrorCode,
        this.subfield.invalidArgNumberErrorMessage
      ), !1;
    let a = !1;
    for (let o = 0; o < n.length; o += 1) {
      const u = this.subfield.argValidators[o].validateArg(n[o], r);
      u.length > 0 && (this.errors.push(...u), a = !0);
    }
    if (this.subfield.shouldRegister && !a) {
      const o = this.registerSubField(t, n[0]).unwrap_or(void 0);
      a = o === void 0 || a, t.symbol = o;
    }
    return !a;
  }
  registerSubField(t, r) {
    if (!this.declarationNode.symbol || !this.declarationNode.symbol.symbolTable)
      throw new Error("If an element allows registering subfields, it must own a symbol table");
    if (!Xe(r))
      throw new Error("If an element allows registering subfields, their name must be simple");
    const s = ve(r).unwrap().value, { symbolTable: n } = this.declarationNode.symbol;
    if (!s)
      throw new Error(`${this.elementKind} subfield's name shouldn't be empty`);
    const i = fr(s, this.context.name);
    if (!i)
      throw new Error(
        `${this.elementKind} fails to create subfield id to register in the symbol table`
      );
    if (n.has(i))
      return this.logError(
        r,
        this.subfield.duplicateErrorCode,
        `${this.elementKind} ${Ve(this.elementKind)} "${s}" has been defined`
      ), new T();
    const a = Er(t, this.context.name, this.symbolFactory);
    if (!a)
      throw new Error(
        `${this.elementKind} fails to create subfield symbol to register in the symbol table`
      );
    return new I(n.get(i, a));
  }
  validateSubFieldSettingList(t) {
    return !(t instanceof U) && !this.subfield.settingList.optional ? (this.logError(
      t,
      this.subfield.settingList.notOptionalErrorCode,
      `A(n) ${this.elementKind} ${Ve(this.elementKind)} must have a setting list`
    ), !1) : t instanceof U && !this.subfield.settingList.allow ? (this.logError(
      t,
      this.subfield.settingList.notAllowErrorCode,
      `A(n) ${this.elementKind} ${Ve(
        this.elementKind
      )}  should not have a setting list`
    ), !1) : t instanceof U ? this.validateSettingListContent(t, this.subfield.settingList) : !0;
  }
  validateSettingListContent(t, r) {
    var i;
    const s = /* @__PURE__ */ new Set();
    let n = !1;
    for (const a of t.elementList) {
      const o = (i = le(a.name).unwrap_or(void 0)) == null ? void 0 : i.toLowerCase(), { value: u } = a;
      o !== void 0 && (r.isValid(o, u).isOk() ? s.has(o) && !r.allowDuplicate(o).unwrap() ? (this.logError(a, r.duplicateErrorCode, "Duplicate setting"), n = !0) : (s.add(o), r.isValid(o, u).unwrap() || (this.logError(a, r.invalidErrorCode, "Invalid value for this setting"), n = !0)) : (this.logError(a, r.unknownErrorCode, "Unknown setting"), n = !0));
    }
    return !n;
  }
  logError(t, r, s) {
    if (r === void 0)
      throw Error(`This error shouldn't exist. Maybe a validator is misconfigured
       Error message: ${s}`);
    this.errors.push(new w(r, s, t));
  }
}
class F {
  constructor(t) {
    this.partialConfig = t;
  }
  doNotStopOnError() {
    return this.partialConfig.stopOnError = !1, this.partialConfig;
  }
  stopOnError() {
    return this.partialConfig.stopOnError = !0, this.partialConfig;
  }
}
const Ft = new F(
  tt({
    allowSimple: !0,
    simpleErrorCode: void 0,
    allowComplex: !0,
    complexErrorCode: void 0,
    stopOnError: !1
  })
), Cr = new F(
  tt({
    allowSimple: !0,
    simpleErrorCode: void 0,
    allowComplex: !1,
    complexErrorCode: c.UNEXPECTED_COMPLEX_BODY,
    stopOnError: !1
  })
), Oe = new F(
  tt({
    allowSimple: !1,
    simpleErrorCode: c.UNEXPECTED_SIMPLE_BODY,
    allowComplex: !0,
    complexErrorCode: void 0,
    stopOnError: !1
  })
), Mr = new F(
  Ut({
    optional: !0,
    notOptionalErrorCode: void 0,
    allow: !0,
    notAllowErrorCode: void 0,
    stopOnError: !1
  })
), Bt = new F(
  et({
    optional: !0,
    notOptionalErrorCode: void 0,
    allow: !0,
    notAllowErrorCode: void 0,
    allowComplex: !0,
    complexErrorCode: void 0,
    shouldRegister: !1,
    duplicateErrorCode: void 0,
    stopOnError: !1
  })
), rt = new F(
  et({
    optional: !1,
    notOptionalErrorCode: c.NAME_NOT_FOUND,
    allow: !0,
    notAllowErrorCode: void 0,
    allowComplex: !0,
    complexErrorCode: void 0,
    shouldRegister: !0,
    duplicateErrorCode: c.DUPLICATE_NAME,
    stopOnError: !1
  })
), V = new F(
  Ne(
    {},
    {
      optional: !0,
      notOptionalErrorCode: void 0,
      allow: !1,
      notAllowErrorCode: c.UNEXPECTED_SETTINGS,
      unknownErrorCode: void 0,
      duplicateErrorCode: void 0,
      invalidErrorCode: void 0,
      stopOnError: !1
    }
  )
);
function Pr(e) {
  return new F(
    Ze({
      globally: !1,
      notGloballyErrorCode: void 0,
      locally: !0,
      notLocallyErrorCode: e,
      stopOnError: !1
    })
  );
}
function Ur(e) {
  return new F(
    Ze({
      globally: !0,
      notGloballyErrorCode: e,
      locally: !1,
      notLocallyErrorCode: void 0,
      stopOnError: !1
    })
  );
}
const be = new F(
  Ze({
    globally: !1,
    notGloballyErrorCode: void 0,
    locally: !1,
    notLocallyErrorCode: void 0,
    stopOnError: !1
  })
), st = new F(
  et({
    optional: !0,
    notOptionalErrorCode: void 0,
    allow: !1,
    notAllowErrorCode: c.UNEXPECTED_NAME,
    allowComplex: !1,
    complexErrorCode: c.UNEXPECTED_NAME,
    shouldRegister: !1,
    duplicateErrorCode: void 0,
    stopOnError: !1
  })
), he = new F(
  Ut({
    optional: !0,
    notOptionalErrorCode: void 0,
    allow: !1,
    notAllowErrorCode: c.UNEXPECTED_ALIAS,
    stopOnError: !1
  })
);
class Fr extends se {
  constructor(t, r, s, n, i, a, o) {
    super(
      t,
      r,
      s,
      n,
      i,
      a,
      o
    ), this.elementKind = m.CUSTOM, this.context = {
      name: x.CustomContext,
      errorCode: c.INVALID_CUSTOM_CONTEXT,
      stopOnError: !1
    }, this.unique = be.doNotStopOnError(), this.name = st.doNotStopOnError(), this.alias = he.doNotStopOnError(), this.settingList = V.doNotStopOnError(), this.body = Cr.doNotStopOnError(), this.subfield = re({
      argValidators: [
        {
          validateArg: ce(
            J,
            c.INVALID_CUSTOM_ELEMENT_VALUE,
            "This field must be a string literal"
          )
        }
      ],
      invalidArgNumberErrorCode: c.INVALID_CUSTOM_ELEMENT_VALUE,
      invalidArgNumberErrorMessage: "A custom element field must be a single string literal",
      settingList: V.doNotStopOnError(),
      shouldRegister: !1,
      duplicateErrorCode: void 0
    });
  }
}
class Br extends se {
  constructor(t, r, s, n, i, a, o) {
    super(
      t,
      r,
      s,
      n,
      i,
      a,
      o
    ), this.elementKind = m.ENUM, this.context = {
      name: x.EnumContext,
      errorCode: c.INVALID_ENUM_CONTEXT,
      stopOnError: !1
    }, this.unique = be.doNotStopOnError(), this.name = rt.doNotStopOnError(), this.alias = he.doNotStopOnError(), this.settingList = V.doNotStopOnError(), this.body = Oe.doNotStopOnError(), this.subfield = re({
      argValidators: [
        {
          validateArg: ce(
            Y,
            c.INVALID_ENUM_ELEMENT_NAME,
            "This field must be a simple variable"
          )
        }
      ],
      invalidArgNumberErrorCode: c.INVALID_ENUM_ELEMENT,
      invalidArgNumberErrorMessage: "An enum's field must be a simple variable",
      settingList: Vr(),
      shouldRegister: !0,
      duplicateErrorCode: c.DUPLICATE_ENUM_ELEMENT_NAME
    });
  }
}
const Vr = () => Ne(
  {
    note: {
      allowDuplicate: !0,
      isValid: J
    }
  },
  {
    optional: !0,
    notOptionalErrorCode: void 0,
    allow: !0,
    notAllowErrorCode: void 0,
    unknownErrorCode: c.UNKNOWN_ENUM_ELEMENT_SETTING,
    duplicateErrorCode: c.DUPLICATE_ENUM_ELEMENT_SETTING,
    invalidErrorCode: c.INVALID_ENUM_ELEMENT_SETTING,
    stopOnError: !1
  }
);
class Gr extends se {
  constructor(t, r, s, n, i, a, o) {
    super(
      t,
      r,
      s,
      n,
      i,
      a,
      o
    ), this.elementKind = m.INDEXES, this.context = {
      name: x.IndexesContext,
      errorCode: c.INVALID_INDEXES_CONTEXT,
      stopOnError: !1
    }, this.unique = be.doNotStopOnError(), this.name = st.doNotStopOnError(), this.alias = he.doNotStopOnError(), this.settingList = V.doNotStopOnError(), this.body = Oe.doNotStopOnError(), this.subfield = re({
      argValidators: [
        {
          validateArg: ce(
            (u) => Pt(u).unwrap_or(void 0) !== void 0,
            c.INVALID_INDEX,
            "This field must be a function expression, a column name or a tuple of such"
          )
        }
      ],
      invalidArgNumberErrorCode: c.INVALID_INDEX,
      invalidArgNumberErrorMessage: "An Indexes field must be a function expression, a column name or a tuple of such",
      settingList: $r(),
      shouldRegister: !1,
      duplicateErrorCode: void 0
    });
  }
}
function Xr(e) {
  var r;
  if (!(e instanceof S) || !(e.expression instanceof M))
    return !1;
  const t = (r = e.expression.variable) == null ? void 0 : r.value;
  return t === "btree" || t === "hash";
}
const $r = () => Ne(
  {
    note: {
      allowDuplicate: !1,
      isValid: J
    },
    name: {
      allowDuplicate: !1,
      isValid: J
    },
    type: {
      allowDuplicate: !1,
      isValid: Xr
    },
    unique: {
      allowDuplicate: !1,
      isValid: Z
    },
    pk: {
      allowDuplicate: !1,
      isValid: Z
    }
  },
  {
    optional: !0,
    notOptionalErrorCode: void 0,
    allow: !0,
    notAllowErrorCode: void 0,
    unknownErrorCode: c.UNKNOWN_INDEX_SETTING,
    duplicateErrorCode: c.DUPLICATE_INDEX_SETTING,
    invalidErrorCode: c.INVALID_INDEX_SETTING_VALUE,
    stopOnError: !1
  }
);
class Wr extends se {
  constructor(t, r, s, n, i, a, o) {
    super(
      t,
      r,
      s,
      n,
      i,
      a,
      o
    ), this.elementKind = m.NOTE, this.context = {
      name: x.NoteContext,
      errorCode: c.INVALID_NOTE_CONTEXT,
      stopOnError: !1
    }, this.unique = Pr(c.NOTE_REDEFINED).doNotStopOnError(), this.name = st.doNotStopOnError(), this.alias = he.doNotStopOnError(), this.settingList = V.doNotStopOnError(), this.body = Ft.doNotStopOnError(), this.subfield = re({
      argValidators: [
        {
          validateArg: (u, h) => h > 0 ? [
            new w(
              c.NOTE_CONTENT_REDEFINED,
              "Only one note content can be defined",
              u
            )
          ] : J(u) ? [] : [
            new w(
              c.INVALID_NOTE,
              "A note's content must be doubly or singly quoted string",
              u
            )
          ]
        }
      ],
      invalidArgNumberErrorCode: c.INVALID_NOTE,
      invalidArgNumberErrorMessage: "A note content must be a doubly or singly quoted string",
      settingList: V.doNotStopOnError(),
      shouldRegister: !1,
      duplicateErrorCode: void 0
    });
  }
}
class qr extends se {
  constructor(t, r, s, n, i, a, o) {
    super(
      t,
      r,
      s,
      n,
      i,
      a,
      o
    ), this.elementKind = m.PROJECT, this.context = {
      name: x.ProjectContext,
      errorCode: c.INVALID_PROJECT_CONTEXT,
      stopOnError: !1
    }, this.unique = Ur(c.PROJECT_REDEFINED).doNotStopOnError(), this.name = Bt.doNotStopOnError(), this.alias = he.doNotStopOnError(), this.settingList = V.doNotStopOnError(), this.body = Oe.doNotStopOnError(), this.subfield = re({
      argValidators: [],
      invalidArgNumberErrorCode: c.INVALID_PROJECT_FIELD,
      invalidArgNumberErrorMessage: "A Project cannot have a subfield",
      settingList: V.doNotStopOnError(),
      shouldRegister: !1,
      duplicateErrorCode: void 0
    });
  }
}
class jr extends se {
  constructor(t, r, s, n, i, a, o) {
    super(
      t,
      r,
      s,
      n,
      i,
      a,
      o
    ), this.elementKind = m.REF, this.context = {
      name: x.RefContext,
      errorCode: c.INVALID_REF_CONTEXT,
      stopOnError: !1
    }, this.unique = be.doNotStopOnError(), this.name = Bt.doNotStopOnError(), this.alias = he.doNotStopOnError(), this.settingList = V.doNotStopOnError(), this.body = Ft.doNotStopOnError(), this.subfield = re({
      argValidators: [
        {
          validateArg: ce(
            Sr,
            c.INVALID_REF_RELATIONSHIP,
            "This field must be a valid binary relationship"
          )
        }
      ],
      invalidArgNumberErrorCode: c.INVALID_REF_FIELD,
      invalidArgNumberErrorMessage: "A ref's field must be a single valid binary relationship",
      settingList: zr(),
      shouldRegister: !1,
      duplicateErrorCode: void 0
    });
  }
}
function pt(e) {
  if (!(Y(e) && e.expression.variable.kind !== l.QUOTED_STRING) && !(e instanceof q))
    return !1;
  let t;
  if (e instanceof q ? t = le(e).unwrap_or("") : t = e.expression.variable.value, t)
    switch (t.toLowerCase()) {
      case "cascade":
      case "no action":
      case "set null":
      case "set default":
      case "restrict":
        return !0;
      default:
        return !1;
    }
  return !1;
}
const zr = () => Ne(
  {
    delete: {
      allowDuplicate: !1,
      isValid: pt
    },
    update: {
      allowDuplicate: !1,
      isValid: pt
    }
  },
  {
    optional: !0,
    notOptionalErrorCode: void 0,
    allow: !0,
    notAllowErrorCode: void 0,
    unknownErrorCode: c.UNKNOWN_REF_SETTING,
    duplicateErrorCode: c.DUPLICATE_REF_SETTING,
    invalidErrorCode: c.INVALID_REF_SETTING_VALUE,
    stopOnError: !1
  }
);
class Kr extends se {
  constructor(t, r, s, n, i, a, o) {
    super(
      t,
      r,
      s,
      n,
      i,
      a,
      o
    ), this.elementKind = m.TABLE, this.context = {
      name: x.TableContext,
      errorCode: c.INVALID_TABLE_CONTEXT,
      stopOnError: !1
    }, this.unique = be.doNotStopOnError(), this.name = rt.doNotStopOnError(), this.alias = Mr.doNotStopOnError(), this.settingList = Ne(
      {
        headercolor: {
          allowDuplicate: !1,
          isValid: rs
        },
        note: {
          allowDuplicate: !1,
          isValid: J
        }
      },
      {
        optional: !0,
        notOptionalErrorCode: void 0,
        allow: !0,
        notAllowErrorCode: void 0,
        unknownErrorCode: c.INVALID_TABLE_SETTING,
        duplicateErrorCode: c.DUPLICATE_TABLE_SETTING,
        invalidErrorCode: c.INVALID_TABLE_SETTING,
        stopOnError: !1
      }
    ), this.body = Oe.doNotStopOnError(), this.subfield = re({
      argValidators: [
        {
          validateArg: ce(
            Y,
            c.INVALID_COLUMN_NAME,
            "This field must be a valid column name"
          )
        },
        {
          validateArg: ce(
            Qr,
            c.INVALID_COLUMN_TYPE,
            "This field must be a valid column type"
          )
        }
      ],
      invalidArgNumberErrorCode: c.INVALID_COLUMN,
      invalidArgNumberErrorMessage: "A Table's column must have a name and a type",
      settingList: Yr(),
      shouldRegister: !0,
      duplicateErrorCode: c.DUPLICATE_COLUMN_NAME
    });
  }
}
function Qr(e) {
  var r, s;
  if (!(e instanceof oe || Pe(e) || e instanceof S))
    return !1;
  if (e instanceof oe) {
    if (e.callee === void 0 || (r = e.argumentList) != null && r.elementList.every((n) => n !== void 0))
      return !0;
    if (!((s = e.argumentList) != null && s.elementList.every(Se)))
      return !1;
    e = e.callee;
  }
  const t = pe(e).unwrap_or(void 0);
  return t !== void 0 && t.length > 0;
}
const Yr = () => Ne(
  {
    note: {
      allowDuplicate: !1,
      isValid: J
    },
    ref: {
      allowDuplicate: !0,
      isValid: ns
    },
    "primary key": {
      allowDuplicate: !1,
      isValid: Z
    },
    default: {
      allowDuplicate: !1,
      isValid: ss
    },
    increment: {
      allowDuplicate: !1,
      isValid: Z
    },
    "not null": {
      allowDuplicate: !1,
      isValid: Z
    },
    null: {
      allowDuplicate: !1,
      isValid: Z
    },
    pk: {
      allowDuplicate: !1,
      isValid: Z
    },
    unique: {
      allowDuplicate: !1,
      isValid: Z
    }
  },
  {
    optional: !0,
    notOptionalErrorCode: void 0,
    allow: !0,
    notAllowErrorCode: void 0,
    unknownErrorCode: c.UNKNOWN_COLUMN_SETTING,
    duplicateErrorCode: c.DUPLICATE_COLUMN_SETTING,
    invalidErrorCode: c.INVALID_COLUMN_SETTING_VALUE,
    stopOnError: !1
  }
);
class Hr extends se {
  constructor(t, r, s, n, i, a, o) {
    super(
      t,
      r,
      s,
      n,
      i,
      a,
      o
    ), this.elementKind = m.TABLEGROUP, this.context = {
      name: x.TableGroupContext,
      errorCode: c.INVALID_TABLEGROUP_CONTEXT,
      stopOnError: !1
    }, this.unique = be.doNotStopOnError(), this.name = rt.doNotStopOnError(), this.alias = he.doNotStopOnError(), this.settingList = V.doNotStopOnError(), this.body = Oe.doNotStopOnError(), this.subfield = re({
      argValidators: [
        {
          validateArg: ce(
            Wt,
            c.INVALID_TABLEGROUP_ELEMENT_NAME,
            "This field must be a valid table name"
          )
        }
      ],
      invalidArgNumberErrorCode: c.INVALID_TABLEGROUP_FIELD,
      invalidArgNumberErrorMessage: "A TableGroup field must be a single valid table name",
      settingList: V.doNotStopOnError(),
      shouldRegister: !1,
      duplicateErrorCode: void 0
    });
  }
}
const Vt = ["null", "true", "false"], Gt = ["-", "+"];
function Xt(e) {
  switch (e.toLowerCase()) {
    case "enum":
      return m.ENUM;
    case "table":
      return m.TABLE;
    case "tablegroup":
      return m.TABLEGROUP;
    case "project":
      return m.PROJECT;
    case "ref":
      return m.REF;
    case "note":
      return m.NOTE;
    case "indexes":
      return m.INDEXES;
    default:
      return m.CUSTOM;
  }
}
function $t(e) {
  switch (Xt(e.type.value)) {
    case m.ENUM:
      return Br;
    case m.TABLE:
      return Kr;
    case m.TABLEGROUP:
      return Hr;
    case m.PROJECT:
      return qr;
    case m.REF:
      return jr;
    case m.NOTE:
      return Wr;
    case m.INDEXES:
      return Gr;
    default:
      return Fr;
  }
}
function Wt(e) {
  return !!pe(e).unwrap_or(!1);
}
function Jr(e) {
  return Xe(e);
}
function Xe(e) {
  return e instanceof S && e.expression instanceof M;
}
function Zr(e) {
  return e instanceof U;
}
function Nt(e) {
  return e.body instanceof j && !e.bodyColon;
}
function es(e) {
  return !!e.bodyColon;
}
function ts(e, t, r) {
  var n;
  let s = t;
  for (const i of e) {
    let a;
    const o = je(i);
    if (s.has(o)) {
      if (a = (n = s.get(o)) == null ? void 0 : n.symbolTable, !a)
        throw new Error("Expect a symbol table in a schema symbol");
    } else {
      a = new we();
      const u = r.create(St, { symbolTable: a });
      s.set(o, u);
    }
    s = a;
  }
  return s;
}
function qt(e) {
  return e === "-" || e === "<>" || e === ">" || e === "<";
}
function rs(e) {
  var r;
  if (!(e instanceof S) || !(e.expression instanceof ue) || ((r = e.expression.literal) == null ? void 0 : r.kind) !== l.COLOR_LITERAL)
    return !1;
  const t = e.expression.literal.value;
  if (t.length !== 4 && t.length !== 7 || t[0] !== "#")
    return !1;
  for (let s = 1; s < t.length; s += 1)
    if (!Nr(t[s]))
      return !1;
  return !0;
}
function Z(e) {
  return e === void 0 || !Array.isArray(e) && e.end === -1 && e.start === -1 || Array.isArray(e) && e.length === 0;
}
function ss(e) {
  var r;
  if (e instanceof S && (e.expression instanceof ue || e.expression instanceof M) || e instanceof z && Gt.includes((r = e.op) == null ? void 0 : r.value) && Se(e.expression) || e instanceof B)
    return !0;
  if (!e || Array.isArray(e) || !Pe(e))
    return !1;
  const t = pe(e).unwrap_or(void 0);
  return t !== void 0 && t.length > 0;
}
function Se(e) {
  var t;
  return e instanceof S && e.expression instanceof ue && ((t = e.expression.literal) == null ? void 0 : t.kind) === l.NUMERIC_LITERAL;
}
function ns(e) {
  var r;
  if (!(e instanceof z) || !qt((r = e.op) == null ? void 0 : r.value))
    return !1;
  const t = pe(e.expression).unwrap_or(void 0);
  return t !== void 0 && t.length > 0;
}
function jt(e) {
  return e instanceof Q && e.elementList.every(Y);
}
class bt {
  constructor(t, r) {
    this.ast = t, this.contextStack = new ar(), this.errors = [], this.symbolFactory = r, this.publicSchemaSymbol = this.symbolFactory.create(St, {
      symbolTable: new we()
    }), this.kindsGloballyFound = /* @__PURE__ */ new Set(), this.kindsLocallyFound = /* @__PURE__ */ new Set(), this.ast.symbol = this.publicSchemaSymbol, this.ast.symbol.declaration = this.ast;
  }
  validate() {
    return this.ast.body.forEach((t) => {
      if (t.parent = this.ast, t.type === void 0)
        return;
      const r = t, s = $t(r);
      new s(
        r,
        this.publicSchemaSymbol,
        this.contextStack,
        this.errors,
        this.kindsGloballyFound,
        this.kindsLocallyFound,
        this.symbolFactory
      ).validate();
    }), new H(this.ast, this.errors);
  }
}
class ne {
  constructor(t, r) {
    this.declarationNode = t, this.errors = r;
  }
  bind() {
    this.bindSettingList(this.declarationNode.attributeList, this.settingList), this.bindBody();
  }
  bindSettingList(t, r) {
    if (t)
      for (const s of t.elementList) {
        const n = le(s.name).unwrap_or(void 0);
        if (!n)
          continue;
        const i = r[n.toLowerCase()];
        i != null && i.shouldBind && this.scanAndBind(s.value, i);
      }
  }
  bindBody() {
    const t = this.declarationNode;
    if (!t.body)
      return;
    const { body: r } = t;
    if (r instanceof j)
      for (const s of r.body)
        if (s instanceof A && s.type) {
          const n = zt(s);
          new n(s, this.errors).bind();
        } else
          this.bindSubfield(s);
    else
      this.bindSubfield(r);
  }
  bindSubfield(t) {
    if (t instanceof A)
      return;
    const r = [t.callee, ...t.args], s = C.last(r);
    s instanceof U && (r.pop(), this.bindSettingList(s, this.subfield.settingList));
    const { argBinderRules: n } = this.subfield.arg;
    for (let i = 0; i < Math.min(r.length, n.length); i += 1)
      n[i].shouldBind && this.scanAndBind(r[i], n[i]);
  }
  // Scan for variable node and member access expression in the node to bind
  scanAndBind(t, r) {
    var s, n;
    if (t)
      if (t instanceof S) {
        if (t.expression instanceof M && ((n = r.keywords) != null && n.includes((s = t.expression.variable) == null ? void 0 : s.value)))
          return;
        this.bindFragments([t], r);
      } else
        t instanceof K ? Pe(t) ? this.bindFragments(Ee(t).unwrap_or([]), r) : (this.scanAndBind(t.leftExpression, r), this.scanAndBind(t.rightExpression, r)) : t instanceof z ? this.scanAndBind(t.expression, r) : t instanceof Ce ? this.scanAndBind(t.expression, r) : t instanceof Q && t.elementList.forEach((i) => this.scanAndBind(i, r));
  }
  // Bind the fragments of a member access expression
  // which can be a simple expression like v1.User,
  // or a complex tuple like v1.User.(id, name)
  bindFragments(t, r) {
    if (t.length === 0)
      return;
    const s = [...r.topSubnamesSymbolKind], { remainingSubnamesSymbolKind: n } = r, i = t.findIndex((p) => !Y(p)), o = i !== -1 && jt(t[i]) ? t[i] : void 0, u = i >= 0 ? s.pop() : void 0, h = t.slice(
      0,
      i === -1 ? void 0 : i
    );
    if (h.length === 0)
      return;
    const b = [];
    for (; s.length && h.length; ) {
      const p = s.pop(), f = h.pop(), _ = W(f).unwrap();
      b.unshift({
        index: Be(_, p),
        referrer: f
      });
    }
    for (; h.length; ) {
      const p = h.pop(), f = W(p).unwrap();
      b.unshift({
        index: Be(f, n),
        referrer: p
      });
    }
    return o ? o.elementList.forEach(
      (p) => this.resolveIndexStack(
        [
          ...b,
          {
            index: Be(
              W(p).unwrap(),
              u
            ),
            referrer: p
          }
        ],
        r.ignoreNameNotFound
      )
    ) : this.resolveIndexStack(b, r.ignoreNameNotFound);
  }
  // Looking up the indexes in the subname stack from the current declaration node
  // Each time the index resolves to a symbol, the referrer's symbol is bound to it
  resolveIndexStack(t, r) {
    if (t.length === 0)
      throw new Error("Unreachable - An unresolved name must have at least one name component");
    const [s, ...n] = t, i = Rr(s.index, this.declarationNode);
    if (i === void 0) {
      const { kind: h, name: b } = ee(s.index).unwrap();
      this.logError(s.referrer, `Can not find ${h} '${b}'`, r);
      return;
    }
    i.references.push(s.referrer), s.referrer.referee = i;
    let a = i.symbolTable, { kind: o, name: u } = ee(s.index).unwrap();
    for (const h of n) {
      const { kind: b, name: p } = ee(h.index).unwrap(), f = a.get(h.index);
      if (!f) {
        this.logError(
          h.referrer,
          `${o} '${u}' does not have ${b} '${p}'`,
          r
        );
        return;
      }
      if (o = b, u = p, h.referrer.referee = f, f.references.push(h.referrer), !f.symbolTable)
        break;
      a = f.symbolTable;
    }
  }
  logError(t, r, s) {
    s || this.errors.push(new w(c.BINDING_ERROR, r, t));
  }
}
class is extends ne {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: []
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class as extends ne {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [{ shouldBind: !1 }]
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class os extends ne {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [N.Table, N.Column],
            remainingSubnamesSymbolKind: N.Schema,
            ignoreNameNotFound: !1
          }
        ]
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class ls extends ne {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [{ shouldBind: !1 }]
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class cs extends ne {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: []
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class us extends ne {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [N.Table, N.Column],
            remainingSubnamesSymbolKind: N.Schema,
            ignoreNameNotFound: !1
          }
        ]
      },
      settingList: {}
    }, this.settingList = {};
  }
}
class hs extends ne {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [
          { shouldBind: !1 },
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [N.Enum],
            remainingSubnamesSymbolKind: N.Schema,
            ignoreNameNotFound: !0
          }
        ]
      },
      settingList: {
        ref: {
          shouldBind: !0,
          topSubnamesSymbolKind: [N.Table, N.Column],
          remainingSubnamesSymbolKind: N.Schema,
          ignoreNameNotFound: !1
        },
        default: {
          shouldBind: !0,
          topSubnamesSymbolKind: [N.Enum, N.EnumField],
          remainingSubnamesSymbolKind: N.Schema,
          ignoreNameNotFound: !1,
          keywords: Vt
        }
      }
    }, this.settingList = {};
  }
}
class ds extends ne {
  constructor() {
    super(...arguments), this.subfield = {
      arg: {
        argBinderRules: [
          {
            shouldBind: !0,
            topSubnamesSymbolKind: [N.Table],
            remainingSubnamesSymbolKind: N.Schema,
            ignoreNameNotFound: !1
          }
        ]
      },
      settingList: {}
    }, this.settingList = {};
  }
}
function zt(e) {
  switch (Xt(e.type.value)) {
    case m.ENUM:
      return as;
    case m.TABLE:
      return hs;
    case m.TABLEGROUP:
      return ds;
    case m.PROJECT:
      return cs;
    case m.REF:
      return us;
    case m.NOTE:
      return ls;
    case m.INDEXES:
      return os;
    default:
      return is;
  }
}
class fs {
  constructor(t) {
    this.ast = t, this.errors = [];
  }
  resolve() {
    for (const t of this.ast.body)
      if (t.type) {
        const r = zt(t);
        new r(t, this.errors).bind();
      }
    return new H(this.ast, this.errors);
  }
}
class Es {
  constructor(t) {
    this.generator = t;
  }
  create(t, r) {
    return new t(r, this.generator.nextId());
  }
}
class ps {
  constructor(t, r) {
    this.ast = t, this.symbolFactory = new Es(r);
  }
  // Analyzing: Invoking both the validator and binder
  analyze() {
    return new bt(this.ast, this.symbolFactory).validate().chain((r) => new fs(r).resolve());
  }
  // For invoking the validator only
  validate() {
    return new bt(this.ast, this.symbolFactory).validate().chain((r) => new H(r, []));
  }
}
function Ns(e, t, r) {
  const s = e.map((a) => a.id), n = t.map((a) => a.id), i = s[0] < n[0] ? `${s.join(",")}_${n.join(",")}` : `${n.join(",")}_${s.join(",")}`;
  return r.has(i) ? !0 : (r.add(i), !1);
}
function bs(e, t) {
  return C.zip(e, t).every(([r, s]) => (r == null ? void 0 : r.id) === (s == null ? void 0 : s.id));
}
function mt(e) {
  switch (e) {
    case "<":
      return ["1", "*"];
    case "<>":
      return ["*", "*"];
    case ">":
      return ["*", "1"];
    case "-":
      return ["1", "1"];
  }
  throw new Error("Invalid relation op");
}
function $e(e, t, r) {
  const { tupleElements: s, variables: n } = Ge(e).unwrap(), i = s || [n.pop()], a = n.pop(), o = n.pop();
  if (n.length > 0)
    return new w(
      c.UNSUPPORTED,
      "Nested schemas are currently not allowed",
      e
    );
  if (a === void 0 && t === null)
    throw new Error("A rel operand's table name must be defined");
  return {
    columnNames: i,
    // if tableName is undefined, the columnName must be relative to the owner
    tableName: a || t,
    schemaName: a ? o || null : r
  };
}
function R(e) {
  return {
    start: {
      offset: e.startPos.offset,
      line: e.startPos.line + 1,
      column: e.startPos.column + 1
    },
    end: { offset: e.endPos.offset, line: e.endPos.line + 1, column: e.endPos.column + 1 }
  };
}
function We(e) {
  var r;
  const t = (r = Ee(e).unwrap_or(void 0)) == null ? void 0 : r.pop();
  return t instanceof Q ? t.elementList.every((s) => !!s.referee) ? new I(t.elementList.map((s) => s.referee)) : new T() : (t == null ? void 0 : t.referee) instanceof Dt ? new I([t.referee]) : new T();
}
function Kt(e) {
  return e.split(`
`).map((t) => t.trim()).join(`
`);
}
class ms {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  insert(t, r) {
    const s = this.map.get(t);
    s === void 0 ? this.map.set(t, [r]) : s.push(r);
  }
  getValue(t) {
    const r = this.map.get(t);
    if (r !== void 0)
      return r[0].value === void 0 ? !0 : r.length >= 2 ? r.map((s) => s.value) : r[0].value;
  }
  getAttributeNode(t) {
    const r = this.map.get(t);
    if (r !== void 0)
      return r.length >= 2 ? r : r[0];
  }
}
function Le(e, t) {
  const r = new ms();
  if (!e)
    return new gt(r, t);
  for (const s of e.elementList) {
    const n = le(s.name).unwrap_or("").toLowerCase();
    r.insert(n, s);
  }
  return new gt(r, t);
}
class gt {
  constructor(t, r) {
    this.settingMap = t, this.errors = r;
  }
  extractNote() {
    const t = this.settingMap.getValue("note");
    return t !== void 0 ? Kt(fe(t).unwrap()) : void 0;
  }
  extractDefault() {
    var s, n, i;
    const t = this.settingMap.getValue("default");
    if (t === void 0)
      return;
    const r = t;
    if (r instanceof S && r.expression instanceof M && Vt.includes((s = r.expression.variable) == null ? void 0 : s.value))
      return {
        type: "boolean",
        value: r.expression.variable.value
      };
    if (Se(r))
      return {
        type: "number",
        value: Number(r.expression.literal.value)
      };
    if (r instanceof z && Gt.includes((n = r.op) == null ? void 0 : n.value) && Se(r.expression))
      return {
        type: "number",
        value: Number(r.expression.expression.literal.value) * (((i = r.op) == null ? void 0 : i.value) === "+" ? 1 : -1)
      };
    if (J(r))
      return {
        value: fe(r).unwrap(),
        type: "string"
      };
    if (r instanceof B)
      return {
        value: r.value.value,
        type: "expression"
      };
    this.errors.push(
      new w(c.UNSUPPORTED, "Unsupported default value", r)
    );
  }
  extractRef(t, r) {
    const s = this.settingMap.getValue("ref");
    if (s === void 0)
      return [];
    const n = Array.isArray(s) ? s : [s], i = [];
    for (const a of n) {
      const o = a.expression, u = $e(o, t, r);
      if (u instanceof w)
        this.errors.push(u);
      else {
        const { columnNames: h, tableName: b, schemaName: p } = u, f = a.op.value;
        i.push({
          schemaName: p,
          tableName: b,
          fieldNames: h,
          relation: f,
          token: R(a),
          referee: We(
            a.expression
          ).unwrap()[0],
          node: a
        });
      }
    }
    return i;
  }
  extractHeaderColor() {
    const t = this.settingMap.getValue("headercolor");
    if (t !== void 0)
      return t.expression.literal.value;
  }
  extractUpdate() {
    const t = this.settingMap.getValue("update");
    if (t !== void 0)
      return t instanceof q ? le(t).unwrap_or("") : t.expression.variable.value;
  }
  extractDelete() {
    const t = this.settingMap.getValue("delete");
    if (t !== void 0)
      return t instanceof q ? le(t).unwrap_or("") : t.expression.variable.value;
  }
  extractIndexType() {
    const t = this.settingMap.getValue("type");
    if (t !== void 0)
      return t.expression.variable.value;
  }
  extractPk() {
    if ((this.settingMap.getValue("pk") || this.settingMap.getValue("primary key")) !== void 0)
      return !0;
  }
  extractUnique() {
    if (this.settingMap.getValue("unique") !== void 0)
      return !0;
  }
  extractIncrement() {
    if (this.settingMap.getValue("increment") !== void 0)
      return !0;
  }
  extractNotNull() {
    const t = this.settingMap.getValue("not null"), r = this.settingMap.getValue("null");
    if (!(t === void 0 && r === void 0)) {
      if (t && r) {
        this.errors.push(
          new w(
            c.CONFLICTING_SETTING,
            "null and not null can not be set at the same time",
            this.settingMap.getAttributeNode("not null")
          )
        );
        return;
      }
      return !!t;
    }
  }
  extractIdxName() {
    const t = this.settingMap.getValue("name");
    if (t !== void 0)
      return fe(t).unwrap();
  }
}
class gs {
  constructor(t) {
    this.ast = t, this.db = {
      schemas: [],
      tables: [],
      refs: [],
      enums: [],
      tableGroups: [],
      aliases: [],
      project: {}
    }, this.endpointPairSet = /* @__PURE__ */ new Set(), this.errors = [];
  }
  interpret() {
    return this.ast.body.forEach((t) => {
      switch (t.type.value.toLowerCase()) {
        case "table":
          ie(this.table(t), this.db.tables);
          break;
        case "ref":
          this.db.refs.push(...this.ref(t, null, null));
          break;
        case "tablegroup":
          ie(this.tableGroup(t), this.db.tableGroups);
          break;
        case "enum":
          ie(this.enum(t), this.db.enums);
          break;
        case "project":
          this.db.project = this.project(t), this.db.project && (this.db.tables.push(...this.db.project.tables), this.db.enums.push(...this.db.project.enums), this.db.tableGroups.push(...this.db.project.tableGroups));
          break;
        default:
          throw new Error("Unreachable - unknown element type");
      }
    }), new H(this.db, this.errors);
  }
  table(t) {
    const r = this.extractElementName(t.name);
    if (!r.isOk())
      return;
    const { name: s, schemaName: n } = r.unwrap(), i = t.alias ? W(t.alias).unwrap_or(null) : null;
    i && this.db.aliases.push({
      name: i,
      kind: "table",
      value: {
        tableName: s,
        schemaName: n
      }
    });
    const a = Le(t.attributeList, this.errors), o = a.extractHeaderColor(), u = a.extractNote();
    let h;
    const b = a.settingMap.getAttributeNode("note"), p = [], f = [], _ = [];
    return t.body.body.forEach((v) => {
      if (v instanceof te) {
        const G = this.column(v, s, n);
        ie(G, p), G != null && G.pk && _.push(G);
      } else if (v instanceof A)
        switch (v.type.value.toLowerCase()) {
          case "ref":
            this.db.refs.push(...this.ref(v, s, n));
            break;
          case "indexes":
            f.push(...this.indexes(v));
            break;
          case "note":
            u !== void 0 ? this.logError(
              v,
              c.NOTE_REDEFINED,
              "Note already appears as a setting of the table"
            ) : h = this.note(v);
            break;
        }
    }), _.length >= 2 && (f.push({
      columns: _.map(({ name: v }) => ({ value: v, type: "column" })),
      token: {
        start: { offset: -1, line: -1, column: -1 },
        // do not make sense to have a meaningful start (?)
        end: { offset: -1, line: -1, column: -1 }
        // do not make sense to have a meaningful end (?)
      },
      pk: !0
    }), _.forEach((v) => v.pk = !1)), {
      name: s,
      schemaName: n,
      alias: i,
      fields: p,
      token: R(t),
      indexes: f,
      headerColor: o,
      note: u === void 0 ? h : {
        value: u,
        token: R(b)
      }
    };
  }
  column(t, r, s) {
    const n = W(t.callee);
    let i = t.args[0], a = null;
    i instanceof oe && (a = i.argumentList.elementList.map((X) => X.expression.literal.value).join(","), i = i.callee);
    const o = this.extractElementName(i);
    if (!o.isOk())
      return;
    const { name: u, schemaName: h } = o.unwrap();
    let b, p, f, _, v, G, me, ge = [];
    const Te = [];
    if (t.args.length === 2) {
      const X = Le(t.args[1], this.errors);
      b = X.extractPk(), p = X.extractIncrement(), f = X.extractUnique(), _ = X.extractNotNull(), me = X.extractDefault(), v = X.extractNote(), G = X.settingMap.getAttributeNode("note"), ge = X.extractRef(r, s), ge.forEach(($) => {
        this.logIfSameEndpoint($.node, [t.symbol], [$.referee]) && this.logIfCircularRefError($.node, [t.symbol], [$.referee]) && (Te.push({
          schemaName: $.schemaName,
          tableName: $.tableName,
          fieldNames: $.fieldNames,
          relation: $.relation,
          token: $.token
        }), this.registerInlineRefEndpoints($, t, r, s));
      });
    }
    return {
      name: n.unwrap(),
      type: {
        schemaName: h,
        type_name: `${u}${a === null ? "" : `(${a})`}`,
        args: a
      },
      token: R(t),
      inline_refs: Te,
      pk: b,
      unique: f,
      not_null: _,
      dbdefault: me,
      increment: p,
      note: v === void 0 ? void 0 : {
        value: v,
        token: R(G)
      }
    };
  }
  registerInlineRefEndpoints(t, r, s, n) {
    const [i, a] = mt(t.relation), o = {
      schemaName: null,
      name: null,
      endpoints: [
        {
          schemaName: n,
          tableName: s,
          fieldNames: [W(r.callee).unwrap()],
          relation: i,
          token: R(r)
        },
        {
          schemaName: t.schemaName,
          tableName: t.tableName,
          fieldNames: t.fieldNames,
          relation: a,
          token: t.token
        }
      ],
      token: t.token
    };
    this.db.refs.push(o);
  }
  ref(t, r, s) {
    let n = null, i = null;
    if (t.name) {
      const o = this.extractElementName(t.name);
      if (!o.isOk())
        return [];
      n = o.unwrap().schemaName, i = o.unwrap().name;
    }
    if (!(t.body instanceof j)) {
      const o = this.refField(
        t.body,
        n,
        i,
        r,
        s
      );
      return o ? [o] : [];
    }
    const a = [];
    for (const o of t.body.body) {
      const u = this.refField(
        o,
        n,
        i,
        r,
        s
      );
      u && a.push(u);
    }
    return a;
  }
  refField(t, r, s, n, i) {
    const a = [t.callee, ...t.args], o = a[0], [u, h] = mt(o.op.value), b = We(o.leftExpression).unwrap(), p = We(o.rightExpression).unwrap();
    if (!this.logIfUnequalFields(o, b, p) || !this.logIfSameEndpoint(o, b, p) || !this.logIfCircularRefError(o, b, p))
      return;
    const f = $e(o.leftExpression, n, i), _ = $e(o.rightExpression, n, i);
    if (f instanceof w && this.errors.push(f), _ instanceof w && this.errors.push(_), f instanceof w || _ instanceof w)
      return;
    const v = {
      schemaName: f.schemaName,
      tableName: f.tableName,
      fieldNames: f.columnNames,
      relation: u,
      token: R(o.leftExpression)
    }, G = {
      schemaName: _.schemaName,
      tableName: _.tableName,
      fieldNames: _.columnNames,
      relation: h,
      token: R(o.rightExpression)
    };
    let me, ge;
    if (a.length === 2) {
      const Te = Le(a[1], this.errors);
      me = Te.extractDelete(), ge = Te.extractUpdate();
    }
    return {
      name: s,
      endpoints: [v, G],
      onDelete: me,
      onUpdate: ge,
      token: R(o),
      schemaName: r
    };
  }
  enum(t) {
    const r = this.extractElementName(t.name);
    if (!r.isOk())
      return;
    const { name: s, schemaName: n } = r.unwrap(), i = t.body.body.map(
      (a) => this.enumField(a)
    );
    return {
      name: s,
      schemaName: n,
      token: R(t),
      values: i
    };
  }
  enumField(t) {
    const r = [t.callee, ...t.args];
    let s, n;
    if (r.length === 2) {
      const i = Le(r[1], this.errors);
      s = i.extractNote(), n = i.settingMap.getAttributeNode("note");
    }
    return {
      name: W(r[0]).unwrap(),
      token: R(t),
      note: s === void 0 ? void 0 : {
        value: s,
        token: R(n)
      }
    };
  }
  project(t) {
    var s;
    const r = {
      name: ((s = t.name && W(t.name)) == null ? void 0 : s.unwrap()) || null,
      tables: [],
      refs: [],
      enums: [],
      tableGroups: [],
      note: void 0
    };
    return t.body.body.forEach((n) => {
      const i = n, a = i.type.value.toLowerCase();
      switch (a) {
        case "table":
          ie(this.table(i), r.tables);
          break;
        case "ref":
          r.refs.push(...this.ref(i, null, null));
          break;
        case "tablegroup":
          ie(this.tableGroup(i), r.tableGroups);
          break;
        case "enum":
          ie(this.enum(i), r.enums);
          break;
        case "note":
          r.note = this.note(i);
          break;
        default:
          r[a] = this.custom(i);
          break;
      }
    }), r;
  }
  // eslint-disable-next-line class-methods-use-this
  custom(t) {
    return fe(t.body.callee).unwrap_or("");
  }
  tableGroup(t) {
    const r = this.extractElementName(t.name);
    if (!r.isOk())
      return;
    const { name: s, schemaName: n } = r.unwrap(), i = [];
    for (const a of t.body.body) {
      const o = this.tableGroupField(a);
      o && i.push(o);
    }
    return {
      name: s,
      schemaName: n,
      tables: i,
      token: R(t)
    };
  }
  tableGroupField(t) {
    const r = this.extractElementName(t.callee);
    if (!r.isOk())
      return;
    const { name: s, schemaName: n } = r.unwrap();
    return {
      name: s,
      schemaName: n
    };
  }
  // eslint-disable-next-line class-methods-use-this
  note(t) {
    if (t.body instanceof j && t.body.body.length === 0)
      return;
    const r = t.body instanceof j ? fe(
      t.body.body[0].callee
    ) : fe(t.body.callee);
    return {
      value: Kt(r.unwrap()),
      token: R(t)
    };
  }
  indexes(t) {
    const r = [];
    for (const s of t.body.body) {
      const n = this.indexField(s);
      n && r.push(n);
    }
    return r;
  }
  indexField(t) {
    const r = [t.callee, ...t.args], { functional: s, nonFunctional: n } = Pt(r[0]).unwrap();
    let i, a, o, u, h, b;
    if (r.length === 2) {
      const p = Le(r[1], this.errors);
      i = p.extractPk(), a = p.extractUnique(), o = p.extractIdxName(), u = p.extractNote(), h = p.settingMap.getAttributeNode("note"), b = p.extractIndexType();
    }
    return {
      columns: [
        ...s.map((p) => ({
          value: p.value.value,
          type: "expression"
        })),
        ...n.map((p) => ({
          value: W(p).unwrap(),
          type: "column"
        }))
      ],
      token: R(t),
      type: b,
      pk: i,
      unique: a,
      name: o,
      note: u === void 0 ? void 0 : {
        value: u,
        token: R(h)
      }
    };
  }
  extractElementName(t) {
    const r = pe(t).unwrap(), s = r.pop(), n = r.pop();
    return r.length > 0 ? (this.logError(
      t,
      c.UNSUPPORTED,
      "Nested schemas are currently not allowed"
    ), new T()) : new I({
      name: s,
      // eslint-disable-next-line no-unneeded-ternary
      schemaName: n || null
    });
  }
  logIfUnequalFields(t, r, s) {
    return r.length !== s.length ? (this.logError(
      t,
      c.UNEQUAL_FIELDS_BINARY_REF,
      "Two endpoints have unequal number of fields"
    ), !1) : !0;
  }
  logIfSameEndpoint(t, r, s) {
    return bs(r, s) ? (this.logError(t, c.SAME_ENDPOINT, "Two endpoints are the same"), !1) : !0;
  }
  logIfCircularRefError(t, r, s) {
    return Ns(r, s, this.endpointPairSet) ? (this.logError(
      t,
      c.UNSUPPORTED,
      "Reference with the same endpoints already exists"
    ), !1) : !0;
  }
  logError(t, r, s) {
    this.errors.push(new w(r, s, t));
  }
}
function ie(e, t) {
  e !== void 0 && t.push(e);
}
var g = /* @__PURE__ */ ((e) => (e[e.Function = 1] = "Function", e[e.Constructor = 2] = "Constructor", e[e.Field = 3] = "Field", e[e.Variable = 4] = "Variable", e[e.Class = 5] = "Class", e[e.Struct = 6] = "Struct", e[e.Interface = 7] = "Interface", e[e.Module = 8] = "Module", e[e.Property = 9] = "Property", e[e.Event = 10] = "Event", e[e.Operator = 11] = "Operator", e[e.Unit = 12] = "Unit", e[e.Value = 13] = "Value", e[e.Constant = 14] = "Constant", e[e.Enum = 15] = "Enum", e[e.EnumMember = 16] = "EnumMember", e[e.Keyword = 17] = "Keyword", e[e.Text = 18] = "Text", e[e.Color = 19] = "Color", e[e.File = 20] = "File", e[e.Reference = 21] = "Reference", e[e.Customcolor = 22] = "Customcolor", e[e.Folder = 23] = "Folder", e[e.TypeParameter = 24] = "TypeParameter", e[e.User = 25] = "User", e[e.Issue = 26] = "Issue", e[e.Snippet = 27] = "Snippet", e))(g || {}), L = /* @__PURE__ */ ((e) => (e[e.None = 0] = "None", e[e.KeepWhitespace = 1] = "KeepWhitespace", e[e.InsertAsSnippet = 4] = "InsertAsSnippet", e))(L || {});
function _e(e) {
  switch (e) {
    case N.Schema:
      return g.Module;
    case N.Table:
      return g.Class;
    case N.Column:
      return g.Field;
    case N.Enum:
      return g.Enum;
    case N.EnumField:
      return g.EnumMember;
    case N.TableGroup:
      return g.Struct;
    case N.TableGroupField:
      return g.Field;
    default:
      return g.Text;
  }
}
function Re(e, t) {
  if (!e || _t(e))
    return !1;
  for (const r of e.trailingTrivia) {
    if (r.start > t)
      break;
    if (r.kind === l.NEWLINE && r.end <= t)
      return !1;
  }
  return !0;
}
function y() {
  return {
    suggestions: []
  };
}
function De(e) {
  return {
    ...e,
    suggestions: e.suggestions.map((t) => ({
      ...t,
      insertText: ` ${t.insertText}`
    }))
  };
}
function Ue(e) {
  return {
    ...e,
    suggestions: e.suggestions.map((t) => ({
      ...t,
      insertText: t.insertText.search(/[^a-zA-Z\d_]/) !== -1 || t.insertText[0].match(/\d/) ? `"${t.insertText}"` : t.insertText
    }))
  };
}
function nt(e, t) {
  return e.getOffsetAt(t);
}
class Qt {
  constructor(t, r = []) {
    this.compiler = t, this.triggerCharacters = r;
  }
  provideCompletionItems(t, r) {
    var b, p;
    const s = nt(t, r), n = this.compiler.token.flatStream(), { token: i, index: a } = this.compiler.container.token(s), o = a === void 0 ? n[0] : n[a + 1];
    if ([
      ...(i == null ? void 0 : i.trailingTrivia) || [],
      ...(i == null ? void 0 : i.leadingTrivia) || [],
      ...(o == null ? void 0 : o.leadingTrivia) || []
    ].find((f) => rr(f) && Ae(s, f)))
      return y();
    if (a === void 0)
      return At();
    if ([l.STRING_LITERAL, l.QUOTED_STRING].includes(i.kind) && Ae(s, i))
      return y();
    const u = this.compiler.container.element(s);
    if (this.compiler.container.scopeKind(s) === k.TOPLEVEL || u instanceof A && u.type && u.type.start <= s && u.type.end >= s)
      return At();
    const h = [...this.compiler.container.stack(s)].reverse();
    for (const f of h)
      if (f instanceof z)
        switch ((b = f.op) == null ? void 0 : b.value) {
          case ">":
          case "<":
          case "<>":
          case "-":
            return Tt(
              this.compiler,
              s,
              f
            );
        }
      else if (f instanceof K)
        switch ((p = f.op) == null ? void 0 : p.value) {
          case ">":
          case "<":
          case "<>":
          case "-":
            return Tt(
              this.compiler,
              s,
              f
            );
          case ".":
            return Yt(
              this.compiler,
              s,
              f
            );
        }
      else {
        if (f instanceof xe)
          return It(this.compiler, s, f);
        if (f instanceof U)
          return It(this.compiler, s, f);
        if (f instanceof Q)
          return Ts(this.compiler, s);
        if (f instanceof te)
          return wt(this.compiler, s, f);
        if (f instanceof A && (f.bodyColon && s >= f.bodyColon.end || f.body && Ae(s, f.body)))
          return wt(this.compiler, s, void 0);
      }
    return y();
  }
}
function Tt(e, t, r) {
  const s = e.container.scopeKind(t);
  if ([k.REF, k.TABLE].includes(s)) {
    const n = Fe(e, t, e.container.element(t), [
      N.Table,
      N.Schema,
      N.Column
    ]);
    return Re(r.op, t) ? De(n) : n;
  }
  return y();
}
function Fe(e, t, r, s) {
  var a;
  if (r === void 0)
    return y();
  let n = r;
  const i = { suggestions: [] };
  for (; n; ) {
    if ((a = n == null ? void 0 : n.symbol) != null && a.symbolTable) {
      const { symbol: o } = n;
      i.suggestions.push(
        ...e.symbol.members(o).filter(({ kind: u }) => s.includes(u)).map(({ name: u, kind: h }) => ({
          label: u,
          insertText: u,
          insertTextRules: L.KeepWhitespace,
          kind: _e(h),
          sortText: _e(h).toString().padStart(2, "0"),
          range: void 0
        }))
      );
    }
    n = n instanceof A ? n.parent : void 0;
  }
  return Ue(i);
}
function Ts(e, t) {
  var s;
  switch (e.container.scopeKind(t)) {
    case k.INDEXES:
      return Jt(e, t);
    case k.REF:
      {
        const n = [...e.container.stack(t)];
        for (; n.length > 0; ) {
          const i = n.pop();
          if (i instanceof K && ((s = i.op) == null ? void 0 : s.value) === ".")
            return Yt(
              e,
              t,
              i
            );
        }
      }
      return Ht(e, t);
  }
  return y();
}
function It(e, t, r) {
  const { token: s } = e.container.token(t);
  if ([l.COMMA, l.LBRACKET].includes(s == null ? void 0 : s.kind)) {
    const n = Lt(e, t);
    return (s == null ? void 0 : s.kind) === l.COMMA && Re(s, t) ? De(n) : n;
  }
  if (r.name && r.name.start <= t && r.name.end >= t)
    return Lt(e, t);
  if (r.name) {
    const n = Is(
      e,
      t,
      le(r.name).unwrap()
    );
    return (s == null ? void 0 : s.kind) === l.COLON && Re(s, t) ? De(n) : n;
  }
  return y();
}
function Lt(e, t) {
  const r = e.container.element(t), s = e.container.scopeKind(t);
  if (r instanceof ae)
    return y();
  if (r.body && !Ae(t, r.body))
    switch (s) {
      case k.TABLE:
        return {
          suggestions: [
            {
              label: "headercolor",
              insertText: "headercolor: ",
              kind: g.Field,
              insertTextRules: L.KeepWhitespace,
              range: void 0
            },
            {
              label: "note",
              insertText: "note: ",
              kind: g.Field,
              insertTextRules: L.KeepWhitespace,
              range: void 0
            }
          ]
        };
      default:
        return y();
    }
  switch (s) {
    case k.TABLE:
      return {
        suggestions: [
          ...["primary key", "null", "not null", "increment", "pk", "unique"].map((n) => ({
            label: n,
            insertText: n,
            kind: g.Property,
            insertTextRules: L.KeepWhitespace,
            range: void 0
          })),
          ...["ref", "default"].map((n) => ({
            label: n,
            insertText: `${n}: `,
            kind: g.Property,
            insertTextRules: L.KeepWhitespace,
            range: void 0
          })),
          {
            label: "note",
            insertText: "note: ",
            kind: g.Property,
            insertTextRules: L.KeepWhitespace,
            range: void 0
          }
        ]
      };
    case k.ENUM:
      return {
        suggestions: [
          {
            label: "note",
            insertText: "note: ",
            kind: g.Property,
            insertTextRules: L.KeepWhitespace,
            range: void 0
          }
        ]
      };
    case k.INDEXES:
      return {
        suggestions: [
          ...["unique", "pk"].map((n) => ({
            label: n,
            insertText: n,
            insertTextRules: L.KeepWhitespace,
            kind: g.Property,
            range: void 0
          })),
          ...["note", "name", "type"].map((n) => ({
            label: n,
            insertText: `${n}: `,
            kind: g.Property,
            insertTextRules: L.KeepWhitespace,
            range: void 0
          }))
        ]
      };
    case k.REF:
      return {
        suggestions: ["update", "delete"].map((n) => ({
          label: n,
          insertText: `${n}: `,
          kind: g.Property,
          insertTextRules: L.KeepWhitespace,
          range: void 0
        }))
      };
  }
  return y();
}
function Is(e, t, r) {
  switch (r == null ? void 0 : r.toLowerCase()) {
    case "update":
    case "delete":
      return {
        suggestions: ["cascade", "set default", "set null", "restrict"].map((s) => ({
          label: s,
          insertText: s,
          kind: g.Value,
          insertTextRules: L.KeepWhitespace,
          range: void 0
        }))
      };
    case "type":
      return {
        suggestions: ["btree", "hash"].map((s) => ({
          label: s,
          insertText: `${s}`,
          kind: g.Value,
          insertTextRules: L.KeepWhitespace,
          range: void 0
        }))
      };
  }
  return y();
}
function Yt(e, t, r) {
  const s = Ee(r).unwrap_or([]);
  if (s.pop(), s.some((i) => !Y(i)))
    return y();
  const n = s.map((i) => Je(i).unwrap());
  return Ue({
    suggestions: e.symbol.ofName({ nameStack: n, owner: e.container.element(t) }).flatMap(({ symbol: i }) => e.symbol.members(i)).map(({ kind: i, name: a }) => ({
      label: a,
      insertText: a,
      kind: _e(i),
      range: void 0
    }))
  });
}
function wt(e, t, r) {
  var n;
  switch (e.container.scopeKind(t)) {
    case k.TABLE:
      return ws(e, t, r);
    case k.PROJECT:
      return As(e, t, r);
    case k.INDEXES:
      return _s(e, t);
    case k.ENUM:
      return Ls(e, t, r);
    case k.REF: {
      const i = Ht(e, t);
      return ((n = e.container.token(t).token) == null ? void 0 : n.kind) === l.COLON && Re(e.container.token(t).token, t) ? De(i) : i;
    }
    case k.TABLEGROUP:
      return xs(e);
    default:
      return y();
  }
}
function At() {
  return {
    suggestions: ["Table", "TableGroup", "Enum", "Project", "Ref"].map((e) => ({
      label: e,
      insertText: e,
      insertTextRules: L.KeepWhitespace,
      kind: g.Keyword,
      range: void 0
    }))
  };
}
function Ls(e, t, r) {
  return r != null && r.callee && it(t, r) === 1 ? Fe(e, t, e.container.element(t), [
    N.Schema,
    N.Table,
    N.Column
  ]) : y();
}
function ws(e, t, r) {
  if (!(r != null && r.callee))
    return {
      suggestions: ["Ref", "Note", "indexes"].map((n) => ({
        label: n,
        insertText: n,
        insertTextRules: L.KeepWhitespace,
        kind: g.Keyword,
        range: void 0
      }))
    };
  const s = it(t, r);
  return s === 0 ? {
    suggestions: ["Ref", "Note", "indexes"].map((n) => ({
      label: n,
      insertText: n,
      insertTextRules: L.KeepWhitespace,
      kind: g.Keyword,
      range: void 0
    }))
  } : s === 1 ? Os(e, t) : y();
}
function As(e, t, r) {
  return r != null && r.callee ? it(t, r) === 0 ? {
    suggestions: ["Table", "TableGroup", "Enum", "Note", "Ref"].map((n) => ({
      label: n,
      insertText: n,
      insertTextRules: L.KeepWhitespace,
      kind: g.Keyword,
      range: void 0
    }))
  } : y() : {
    suggestions: ["Table", "TableGroup", "Enum", "Note", "Ref"].map((n) => ({
      label: n,
      insertText: n,
      insertTextRules: L.KeepWhitespace,
      kind: g.Keyword,
      range: void 0
    }))
  };
}
function Ht(e, t) {
  return Fe(e, t, e.container.element(t), [
    N.Schema,
    N.Table,
    N.Column
  ]);
}
function xs(e) {
  return Ue({
    suggestions: [...e.parse.publicSymbolTable().entries()].flatMap(([t]) => {
      const r = ee(t).unwrap_or(void 0);
      if (r === void 0)
        return [];
      const { kind: s, name: n } = r;
      return s !== N.Table && s !== N.Schema ? [] : {
        label: n,
        insertText: n,
        insertTextRules: L.KeepWhitespace,
        kind: _e(s),
        range: void 0
      };
    })
  });
}
function _s(e, t) {
  return Jt(e, t);
}
function Os(e, t) {
  return {
    suggestions: [
      ...[
        "integer",
        "int",
        "tinyint",
        "smallint",
        "mediumint",
        "bigint",
        "bit",
        "bool",
        "binary",
        "varbinary",
        "logical",
        "char",
        "nchar",
        "varchar",
        "varchar2",
        "nvarchar",
        "nvarchar2",
        "binary_float",
        "binary_double",
        "float",
        "double",
        "decimal",
        "dec",
        "real",
        "money",
        "smallmoney",
        "enum",
        "tinyblob",
        "tinytext",
        "blob",
        "text",
        "mediumblob",
        "mediumtext",
        "longblob",
        "longtext",
        "ntext",
        "set",
        "inet6",
        "uuid",
        "image",
        "date",
        "time",
        "datetime",
        "datetime2",
        "timestamp",
        "year",
        "smalldatetime",
        "datetimeoffset",
        "XML",
        "sql_variant",
        "uniqueidentifier",
        "CURSOR",
        "BFILE",
        "CLOB",
        "NCLOB",
        "RAW"
      ].map((r) => ({
        label: r,
        insertText: r,
        insertTextRules: L.KeepWhitespace,
        kind: g.TypeParameter,
        sortText: g.TypeParameter.toString().padStart(2, "0"),
        range: void 0
      })),
      ...Fe(e, t, e.container.element(t), [
        N.Enum,
        N.Schema
      ]).suggestions
    ]
  };
}
function Jt(e, t) {
  const s = e.container.element(t).parent;
  if (!((s == null ? void 0 : s.symbol) instanceof Rt))
    return y();
  const { symbolTable: n } = s.symbol;
  return Ue({
    suggestions: [...n.entries()].flatMap(([i]) => {
      const a = ee(i).unwrap_or(void 0);
      if (a === void 0)
        return [];
      const { name: o } = a;
      return {
        label: o,
        insertText: o,
        insertTextRules: L.KeepWhitespace,
        kind: _e(N.Column),
        range: void 0
      };
    })
  });
}
function it(e, t) {
  if (!t.callee)
    return -1;
  const r = [t.callee, ...t.args], s = r.findIndex((n) => e <= n.end);
  return s === -1 ? r.length : s;
}
class Zt {
  constructor(t) {
    this.compiler = t;
  }
  provideDefinition(t, r) {
    var a;
    const { uri: s } = t, n = nt(t, r), i = [...this.compiler.container.stack(n)];
    for (; i.length !== 0; ) {
      const o = i.pop();
      if ((a = o == null ? void 0 : o.referee) != null && a.declaration && [de.PRIMARY_EXPRESSION, de.VARIABLE].includes(o == null ? void 0 : o.kind)) {
        const { startPos: u, endPos: h } = o.referee.declaration;
        return [
          {
            range: {
              startColumn: u.column + 1,
              startLineNumber: u.line + 1,
              endColumn: h.column + 1,
              endLineNumber: h.line + 1
            },
            uri: s
          }
        ];
      }
    }
    return [];
  }
}
class er {
  constructor(t) {
    this.compiler = t;
  }
  provideReferences(t, r) {
    const { uri: s } = t, n = nt(t, r), i = [...this.compiler.container.stack(n)];
    for (; i.length !== 0; ) {
      const a = i.pop();
      if (a && [
        de.ELEMENT_DECLARATION,
        de.FUNCTION_APPLICATION,
        de.PRIMARY_EXPRESSION
      ].includes(a == null ? void 0 : a.kind)) {
        const { symbol: o } = a;
        if (o != null && o.references.length)
          return o.references.map(({ startPos: u, endPos: h }) => ({
            range: {
              startColumn: u.column + 1,
              startLineNumber: u.line + 1,
              endColumn: h.column + 1,
              endLineNumber: h.line + 1
            },
            uri: s
          }));
      }
    }
    return [];
  }
}
const ks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CompletionItemInsertTextRule: L,
  CompletionItemKind: g,
  DBMLCompletionItemProvider: Qt,
  DBMLDefinitionProvider: Zt,
  DBMLReferencesProvider: er
}, Symbol.toStringTag, { value: "Module" }));
var k = /* @__PURE__ */ ((e) => (e[e.TABLE = 0] = "TABLE", e[e.ENUM = 1] = "ENUM", e[e.TABLEGROUP = 2] = "TABLEGROUP", e[e.INDEXES = 3] = "INDEXES", e[e.NOTE = 4] = "NOTE", e[e.REF = 5] = "REF", e[e.PROJECT = 6] = "PROJECT", e[e.CUSTOM = 7] = "CUSTOM", e[e.TOPLEVEL = 8] = "TOPLEVEL", e))(k || {});
class Ss {
  constructor() {
    this.source = "", this.cache = new Array(
      16
      /* TOTAL_QUERY_COUNT */
    ).fill(null), this.nodeIdGenerator = new sr(), this.symbolIdGenerator = new or(), this.token = {
      invalidStream: this.createQuery(
        6,
        () => this.parse.tokens().filter(Ct)
      ),
      // Valid + Invalid tokens (which are guarenteed to be non-trivials) are included in the stream
      flatStream: this.createQuery(
        7,
        () => this.parse.tokens().flatMap((t) => [...t.leadingInvalid, t, ...t.trailingInvalid])
      )
    }, this.parse = {
      source: () => this.source,
      _: this.createQuery(
        0,
        () => {
          const t = new Lr(this.source).lex().chain((r) => new xr(r, this.nodeIdGenerator).parse()).chain(({ ast: r, tokens: s }) => new ps(r, this.symbolIdGenerator).analyze().map(() => ({ ast: r, tokens: s })));
          return t.getErrors().length > 0 ? t : t.chain(({ ast: r, tokens: s }) => new gs(r).interpret().map((i) => ({ ast: r, tokens: s, rawDb: i })));
        }
      ),
      ast: this.createQuery(
        1,
        () => this.parse._().getValue().ast
      ),
      errors: this.createQuery(2, () => {
        const t = [...this.parse._().getErrors()];
        return t.sort((r, s) => r.start - s.start), t;
      }),
      tokens: this.createQuery(
        4,
        () => this.parse._().getValue().tokens
      ),
      rawDb: this.createQuery(
        3,
        () => this.parse._().getValue().rawDb
      ),
      publicSymbolTable: this.createQuery(
        5,
        () => this.parse._().getValue().ast.symbol.symbolTable
      )
    }, this.container = {
      stack: this.createQuery(
        10,
        (t) => {
          const r = this.parse.tokens();
          let { index: s } = this.container.token(t);
          const { token: n } = this.container.token(t);
          if (s === void 0)
            return [this.parse.ast()];
          for (; r[s].isInvalid && s >= 0; )
            s -= 1;
          if (s === -1)
            return [this.parse.ast()];
          const i = r[s].start;
          let a = this.parse.ast();
          const o = [a];
          for (; ; ) {
            const h = Tr(a).find((b) => Ae(i, b));
            if (h === void 0 || h instanceof P)
              break;
            o.push(h), a = h;
          }
          if ((n == null ? void 0 : n.kind) === l.COLON)
            return o;
          for (; o.length > 0; ) {
            let u = !1;
            const h = C.last(o);
            if (h instanceof te) {
              const b = this.parse.source();
              for (let p = h.end; p < t; p += 1)
                b[p] === `
` && (o.pop(), u = !0);
            } else
              h instanceof z || h instanceof K ? this.container.token(t).token !== h.op && (o.pop(), u = !0) : h instanceof U ? h.listCloseBracket && h.end <= t && (o.pop(), u = !0) : h instanceof Q ? h.tupleCloseParen && h.end <= t && (o.pop(), u = !0) : h instanceof j ? h.blockCloseBrace && h.end <= t && (o.pop(), u = !0) : h instanceof q || h.end < t && (o.pop(), u = !0);
            if (u) {
              const b = C.last(o);
              b instanceof A && b.end <= t && o.pop();
            }
            if (!u)
              break;
          }
          return o;
        }
      ),
      token: this.createQuery(
        11,
        (t) => {
          const r = this.token.flatStream().findIndex((s) => s.start >= t);
          return r === void 0 ? { token: void 0, index: void 0 } : r <= 0 ? { token: void 0, index: void 0 } : {
            token: this.token.flatStream()[r - 1],
            index: r - 1
          };
        }
      ),
      element: this.createQuery(
        12,
        (t) => {
          const r = this.container.stack(t);
          for (let s = r.length - 1; s >= 0; s -= 1)
            if (r[s] instanceof A)
              return r[s];
          return this.parse.ast();
        }
      ),
      scope: this.createQuery(
        14,
        (t) => {
          var r, s;
          return (s = (r = this.container.element(t)) == null ? void 0 : r.symbol) == null ? void 0 : s.symbolTable;
        }
      ),
      scopeKind: this.createQuery(15, (t) => {
        var s;
        if (this.container.element(t) instanceof ae)
          return 8;
        switch ((s = this.container.element(t).type) == null ? void 0 : s.value.toLowerCase()) {
          case "table":
            return 0;
          case "enum":
            return 1;
          case "ref":
            return 5;
          case "tablegroup":
            return 2;
          case "indexes":
            return 3;
          case "note":
            return 4;
          case "project":
            return 6;
          default:
            return 7;
        }
      })
    }, this.symbol = {
      // Given a stack of name and the current scope
      // Try looking up the first name in the stack in the current scope
      // and resolve the rest of the name stack as members
      // Then try to do the same with all ancestor scopes
      ofName: this.createQuery(
        8,
        ({
          nameStack: t,
          owner: r = this.parse.ast()
        }) => {
          var n;
          if (t.length === 0)
            return [];
          const s = [];
          for (let i = r; i; i = i instanceof A ? i.parent : void 0) {
            if (!((n = i.symbol) != null && n.symbolTable))
              continue;
            const { symbolTable: a } = i.symbol;
            let o = [a], u = [];
            for (const h of t)
              u = o.flatMap(
                (b) => pr(h).flatMap((p) => {
                  const f = b.get(p), _ = ee(p).unwrap_or(void 0);
                  return !f || !_ ? [] : { ..._, symbol: f };
                })
              ), o = u.flatMap(
                (b) => b.symbol.symbolTable ? b.symbol.symbolTable : []
              );
            s.push(...u);
          }
          return s;
        },
        ({ nameStack: t, owner: r }) => `${t.join(".")}@${r.id}`
      ),
      members: this.createQuery(
        9,
        (t) => t.symbolTable ? [...t.symbolTable.entries()].map(([r, s]) => ({
          ...ee(r).unwrap(),
          symbol: s
        })) : []
      )
    };
  }
  createQuery(t, r, s) {
    return (n) => {
      const i = this.cache[t], a = n && s ? s(n) : n;
      if (i !== null) {
        if (!(i instanceof Map))
          return i;
        if (i.has(a))
          return i.get(a);
      }
      const o = r(n);
      return n !== void 0 ? i instanceof Map ? i.set(a, o) : (this.cache[t] = /* @__PURE__ */ new Map(), this.cache[t].set(a, o)) : this.cache[t] = o, o;
    };
  }
  setSource(t) {
    this.source = t, this.cache = new Array(
      16
      /* TOTAL_QUERY_COUNT */
    ).fill(null), this.nodeIdGenerator.reset(), this.symbolIdGenerator.reset();
  }
  initMonacoServices() {
    return {
      definitionProvider: new Zt(this),
      referenceProvider: new er(this),
      autocompletionProvider: new Qt(this)
    };
  }
}
export {
  Ss as Compiler,
  ys as serialize,
  ks as services
};
