"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = generate;
exports.getFormatOpt = getFormatOpt;
exports.resolvePaths = resolvePaths;
exports.validateInputFilePaths = validateInputFilePaths;
var _path2 = _interopRequireDefault(require("path"));
var _fs = _interopRequireDefault(require("fs"));
var _errors = require("../errors");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function resolvePaths(paths) {
  if (!Array.isArray(paths)) {
    return _path2.default.resolve(process.cwd(), paths);
  }
  return paths.map(_path => _path2.default.resolve(process.cwd(), _path));
}
function validateInputFilePaths(paths, validatePlugin) {
  return paths.every(_path => validatePlugin(_path));
}
function getFormatOpt(opts) {
  const formatOpts = Object.keys(opts).filter(opt => {
    return ['postgres', 'mysql', 'mssql', 'postgresLegacy'].includes(opt);
  });
  let format = 'postgres';
  let cnt = 0;
  formatOpts.forEach(opt => {
    if (opts[opt]) {
      cnt += 1;
      if (cnt > 1) throw new Error('Too many format options');
      format = opt;
    }
  });
  return format;
}
function generate(inputPaths, transform, outputPlugin) {
  inputPaths.forEach(_path => {
    const source = _fs.default.readFileSync(_path, 'utf-8');
    try {
      const content = transform(source);
      outputPlugin.write(content);
    } catch (err) {
      if (Array.isArray(err)) {
        throw err.map(e => new _errors.SyntaxError(_path2.default.basename(_path), e));
      }
      throw new _errors.SyntaxError(_path2.default.basename(_path), err);
    }
  });
}